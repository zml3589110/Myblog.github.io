<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>赵逸尘个人博客</title>
  
  <subtitle>记录工作生活</subtitle>
  <link href="https://zml3589110.github.io/atom.xml" rel="self"/>
  
  <link href="https://zml3589110.github.io/"/>
  <updated>2024-07-18T03:38:55.266Z</updated>
  <id>https://zml3589110.github.io/</id>
  
  <author>
    <name>ZhaoYichen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LVGL组件 lv_bar</title>
    <link href="https://zml3589110.github.io/posts/2299103280.html"/>
    <id>https://zml3589110.github.io/posts/2299103280.html</id>
    <published>2024-07-18T03:30:20.000Z</published>
    <updated>2024-07-18T03:38:55.266Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Bar简介"><a href="#一、Bar简介" class="headerlink" title="一、Bar简介"></a>一、Bar简介</h2><h3 id="1-1-Overview（概述）"><a href="#1-1-Overview（概述）" class="headerlink" title="1.1 Overview（概述）"></a>1.1 Overview（概述）</h3><p>进度条指示器的宽度根据进度条的当前值自动设置。如果设置进度条的宽度小于其高度，就可以创建出垂直摆放的进度条。可以通过设置进度条的值，从而改变指标的开始位置。<br>进度条的PART与style都比较简单和明确，本文重点在于对进度条模式mode的理解。</p><h3 id="1-2-Parts-and-Styles（部分和风格）"><a href="#1-2-Parts-and-Styles（部分和风格）" class="headerlink" title="1.2 Parts and Styles（部分和风格）"></a>1.2 Parts and Styles（部分和风格）</h3><ul><li>LV_PART_MAIN 进度条的背景，它使用典型的背景样式属性。 添加填充会让指示器变小或变大。 如果值设置为 LV_ANIM_ON<br>，则可以继续通过设置 anim_time 样式属性设置动画的时间。</li><li>LV_PART_INDICATOR 指示器本身； 也是使用所有典型的背景属性。</li></ul><p>如图，绿色部分是LV_PART_INDICATOR ，暗红色是LV_PART_MAIN 。</p><img src="/posts/undefined/3745e28e970542a88c97d35abaf2eb2f.png" class="" title="在这里插入图片描述"><h2 id="二、Bar-使用"><a href="#二、Bar-使用" class="headerlink" title="二、Bar 使用"></a>二、Bar 使用</h2><h3 id="2-1-Value-and-range（值和范围）"><a href="#2-1-Value-and-range（值和范围）" class="headerlink" title="2.1 Value and range（值和范围）"></a>2.1 Value and range（值和范围）</h3><p>设置进度条的范围：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lv_bar_set_range</span><span class="params">(<span class="keyword">lv_obj_t</span>* obj, <span class="keyword">int32_t</span> min, <span class="keyword">int32_t</span> max)</span></span>;</span><br></pre></td></tr></table></figure><p>设置进度条起始值，可选择是否开启动画LV_ANIM_ON\OFF</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lv_bar_set_start_value</span><span class="params">(<span class="keyword">lv_obj_t</span>* obj, <span class="keyword">int32_t</span> start_value, <span class="keyword">lv_anim_enable_t</span> anim)</span></span>;</span><br></pre></td></tr></table></figure><p>设置进度条新值，可选择是否开启动画LV_ANIM_ON\OFF</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lv_bar_set_value</span><span class="params">(<span class="keyword">lv_obj_t</span>* obj, <span class="keyword">int32_t</span> value, <span class="keyword">lv_anim_enable_t</span> anim)</span></span>;</span><br></pre></td></tr></table></figure><p>涉及到动画，直接LV_ANIM_ON，并不会完全生效，因为动画时间默认设置为 0 ，这里还需要调一下样式的接口函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lv_obj_set_style_anim_time</span><span class="params">(struct <span class="keyword">_lv_obj_t</span>* obj, <span class="keyword">uint32_t</span> value, <span class="keyword">lv_style_selector_t</span> selector)</span></span>;</span><br></pre></td></tr></table></figure><p>Bar控件提供的API接口并不多，但是使用的时候还是有些小技巧，初次使用设置bar的值可能会遇到lv_bar_set_start_value这个接口不生效的情况，这是为什么呢？</p><img src="/posts/undefined/a1d80436858943feb1c91bbe9a2b96a0.png" class="" title="在这里插入图片描述"><p>上图是lv_bar_set_start_value函数的实现，一眼就能发现关键点，bar控件的默认mode是LV_BAR_MODE_NORMAL(普通模式)，只有在LV_BAR_MODE_RANGE(范围模式下该函数才能生效)</p><h3 id="2-1-Modes（模式）"><a href="#2-1-Modes（模式）" class="headerlink" title="2.1 Modes（模式）"></a>2.1 Modes（模式）</h3><p>bar控件一共有三个模式：</p><ul><li><strong>LV_BAR_MODE_NORMAL</strong> 像上文所说的普通进度条(默认)</li><li><strong>LV_BAR_MODE_SYMMETRICAL</strong> 这个模式下可以指定负的最小范围。但是只能从零值到当前值绘制指示器。</li><li><strong>LV_BAR_MODE_RANGE</strong> 这个模式下也可以指定负的最小范围。这样进度条的起始值可以不是0，而是你指定的数值，但是这样设置的起始值(lv_bar_set_start_value)必须小于结束值</li></ul><p>设置bar模式接口</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lv_bar_set_mode</span><span class="params">(<span class="keyword">lv_obj_t</span>* obj, <span class="keyword">lv_bar_mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure><p>普通模式：LV_BAR_MODE_NORMAL<br>可以指定负的最小范围，只能从最左边当前值绘制指示器。 下图范围(-100,100)</p><img src="/posts/undefined/65e6411058884c30834ce59248b496a6.png" class="" title="在这里插入图片描述"><p>对称模式：LV_BAR_MODE_NORMAL<br>可以指定负的最小范围，但是只能从零值到当前值绘制指示器。 下图范围(-100,100)</p><img src="/posts/undefined/bab59d005eb747179c48c8ba5c780ce5.png" class="" title="在这里插入图片描述"><p>0点会根据开始值和结束值计算位置 下图范围(-20,100)</p><img src="/posts/undefined/b9aadb15942f4f0d88a92403bd156a6b.png" class="" title="在这里插入图片描述"><p>范围模式：LV_BAR_MODE_RANGE<br>和对称模式类似，可以指定负的最小范围，注意这里默认的起始位置start_value 是0；这里可以通过设置起始值来设置。下图范围(-100,100) ，起始值是-50，结束值是20</p><img src="/posts/undefined/f0376682cec14be3a57b433e1424cab3.png" class="" title="在这里插入图片描述"><p>可以通过图片看出，设置了开始值，指示器就会从设置的值开始向右开始绘制，范围模式下结束值不能小于开始值，也就是说范围设置是(-100,100)，但是我设置了开始值为-50，那么进度条的背景是已经绘制(-100,100)，但是(-100,-50)这个区间的指示器是不能被绘制的，因为已经限定了开始值为-50，只能从-50 的位置开始绘制指示器</p><h2 id="三、Bar-API"><a href="#三、Bar-API" class="headerlink" title="三、Bar API"></a>三、Bar API</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">lv_obj_t</span> * <span class="title">lv_bar_create</span><span class="params">(<span class="keyword">lv_obj_t</span> * parent)</span></span>;<span class="comment">//创建一个bar对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lv_bar_set_value</span><span class="params">(<span class="keyword">lv_obj_t</span> * obj, <span class="keyword">int32_t</span> value, <span class="keyword">lv_anim_enable_t</span> anim)</span></span>;<span class="comment">//在栏上设置一个新值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lv_bar_set_start_value</span><span class="params">(<span class="keyword">lv_obj_t</span> * obj, <span class="keyword">int32_t</span> start_value, <span class="keyword">lv_anim_enable_t</span> anim)</span></span>;<span class="comment">//在工具条上设置一个新的起始值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lv_bar_set_range</span><span class="params">(<span class="keyword">lv_obj_t</span> * obj, <span class="keyword">int32_t</span> min, <span class="keyword">int32_t</span> max)</span></span>;<span class="comment">//设置一个bar的最小值和最大值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lv_bar_set_mode</span><span class="params">(<span class="keyword">lv_obj_t</span> * obj, <span class="keyword">lv_bar_mode_t</span> mode)</span></span>;<span class="comment">//设置栏的类型。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">lv_bar_get_value</span><span class="params">(<span class="keyword">const</span> <span class="keyword">lv_obj_t</span> * obj)</span></span>;<span class="comment">//获取一个bar的值</span></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">lv_bar_get_start_value</span><span class="params">(<span class="keyword">const</span> <span class="keyword">lv_obj_t</span> * obj)</span></span>;<span class="comment">//获取一个条的起始值</span></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">lv_bar_get_min_value</span><span class="params">(<span class="keyword">const</span> <span class="keyword">lv_obj_t</span> * obj)</span></span>;<span class="comment">//获取一个条形图的最小值</span></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">lv_bar_get_max_value</span><span class="params">(<span class="keyword">const</span> <span class="keyword">lv_obj_t</span> * obj)</span></span>;<span class="comment">//获取一个bar的最大值</span></span><br><span class="line"><span class="function"><span class="keyword">lv_bar_mode_t</span> <span class="title">lv_bar_get_mode</span><span class="params">(<span class="keyword">lv_obj_t</span> * obj)</span></span>;<span class="comment">//获取bar的类型。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="LVGL–进度条部件（lv-bar"><a href="#LVGL–进度条部件（lv-bar" class="headerlink" title="LVGL–进度条部件（lv_bar)"></a>LVGL–进度条部件（lv_bar)</h1><h2 id="进度条部件（lv-bar"><a href="#进度条部件（lv-bar" class="headerlink" title="进度条部件（lv_bar)"></a><a href="https://so.csdn.net/so/search?q=%E8%BF%9B%E5%BA%A6%E6%9D%A1&spm=1001.2101.3001.7020">进度条</a>部件（lv_bar)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">进度条部件常用于显示当前任务的完成进度。</span><br></pre></td></tr></table></figure><img src="/posts/undefined/73faf6c4098e405280cc6979598a327b.png" class="" title="在这里插入图片描述"><p>进度条部件组成部分：<br>主体：LV_PART_MAIN<br>指示器：LV_PART_INDICATOR</p><h3 id="进度条部件的相关API函数"><a href="#进度条部件的相关API函数" class="headerlink" title="进度条部件的相关API函数"></a>进度条部件的相关API函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//知识点1：创建一个进度条部件</span></span><br><span class="line">    <span class="keyword">lv_obj_t</span> *bar = lv_bar_create(lv_scr_act());<span class="comment">//创建一个进度条部件</span></span><br><span class="line">    lv_obj_set_size(bar, <span class="number">200</span>,<span class="number">20</span>);<span class="comment">//设置尺寸大小</span></span><br><span class="line">    lv_obj_set_align(bar,LV_ALIGN_CENTER);<span class="comment">//设置在画面的中心位置</span></span><br><span class="line">    <span class="comment">//设置进度条的大小，当前值，范围值</span></span><br><span class="line">    lv_bar_set_range(bar,<span class="number">-100</span>,<span class="number">100</span>);<span class="comment">//设置进度条的范围值</span></span><br><span class="line">    lv_obj_set_style_anim_time(bar,<span class="number">1000</span>,LV_STATE_DEFAULT);<span class="comment">//设置动画效果，注意需要在当前值设置之前</span></span><br><span class="line">    lv_bar_set_value(bar,<span class="number">-50</span>,LV_ANIM_ON);<span class="comment">//设置进度条的当前值</span></span><br><span class="line">    <span class="comment">//拓展知识点：设置模式，起始值</span></span><br><span class="line">    lv_bar_set_mode(bar,LV_BAR_MODE_SYMMETRICAL);<span class="comment">//修改模式,</span></span><br><span class="line"><span class="comment">//    lv_bar_set_start_value(bar,-50,LV_ANIM_OFF);//修改起始位置</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span>&#123;</span></span><br><span class="line">LV_BAR_MODE_NORMAL,<span class="comment">/*默认模式*/</span></span><br><span class="line">LV_BAR_MODE_SYSMMERTICAL,<span class="comment">/*从零绘制到当前值（当前值可以小于0）*/</span></span><br><span class="line">LV_BAR_MODE_RANGE<span class="comment">/*允许设置起始值，但起始值必须小于当前值*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="进度条使用注意事项（v8-2）版本"><a href="#进度条使用注意事项（v8-2）版本" class="headerlink" title="进度条使用注意事项（v8.2）版本"></a>进度条使用注意事项（v8.2）版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@当进度条高度大于宽度时，其方向变为垂直。</span><br><span class="line">@动画事件设置需要放在当前值之前，否则看不到动画。</span><br><span class="line">@动画事件指的是旧值刷新到新值的绘图时间，并不是现实中当前值变化所需要的时间。</span><br></pre></td></tr></table></figure><hr><h1 id="相关链接-侵删"><a href="#相关链接-侵删" class="headerlink" title="相关链接(侵删)"></a>相关链接(侵删)</h1><ol><li><a href="https://blog.csdn.net/smicd/article/details/135928980">分LVGL8.3 –lv_bar 进度条</a></li><li><a href="https://blog.csdn.net/m0_63472758/article/details/136229482">LVGL–进度条部件（lv_bar)</a></li></ol><hr><center><font color=red>=================我是分割线=================</font></center><p><strong>欢迎到公众号来唠嗑:</strong></p><img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">]]></content>
    
    
    <summary type="html">LVGL 进度条组件 lv_bar</summary>
    
    
    
    <category term="LVGL组件" scheme="https://zml3589110.github.io/categories/LVGL%E7%BB%84%E4%BB%B6/"/>
    
    <category term="GUI" scheme="https://zml3589110.github.io/categories/GUI/"/>
    
    <category term="lv_bar" scheme="https://zml3589110.github.io/categories/LVGL%E7%BB%84%E4%BB%B6/lv-bar/"/>
    
    <category term="LVGL" scheme="https://zml3589110.github.io/categories/LVGL/"/>
    
    
    <category term="C" scheme="https://zml3589110.github.io/tags/C/"/>
    
    <category term="GUI" scheme="https://zml3589110.github.io/tags/GUI/"/>
    
    <category term="LVGL" scheme="https://zml3589110.github.io/tags/LVGL/"/>
    
    <category term="组件" scheme="https://zml3589110.github.io/tags/%E7%BB%84%E4%BB%B6/"/>
    
    <category term="lv_bar" scheme="https://zml3589110.github.io/tags/lv-bar/"/>
    
  </entry>
  
  <entry>
    <title>LVGL启动过程</title>
    <link href="https://zml3589110.github.io/posts/4122746189.html"/>
    <id>https://zml3589110.github.io/posts/4122746189.html</id>
    <published>2024-07-18T03:06:20.000Z</published>
    <updated>2024-07-18T03:20:21.795Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本启动流程"><a href="#基本启动流程" class="headerlink" title="基本启动流程"></a>基本启动流程</h1><p>![img](3. LVGL模拟器NXP GUI Guider使用&#x2F;2109578-20220821111715583-1999413560.png)</p><p>lvgl是gui层负责绘制gui并根据输入设备的事件来响应重绘 ，然后把绘制的缓冲区发送给显示驱动去实际显示。</p><p>以下代码参考lvgl arduino官方例程，gui guider模拟器例程，例如 stm32 fsmc lvgl例程</p><h2 id="第一步-时钟"><a href="#第一步-时钟" class="headerlink" title="第一步 时钟"></a>第一步 时钟</h2><p>时钟是lvgl绘制gui的节拍器。获取时钟在这个文件里  ..\lvgl\src\hal\lv_hal_tick.c</p><p>在arduino 中时钟是从 millis（）这个函数获得的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LV_TICK_CUSTOM 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> LV_TICK_CUSTOM</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> LV_TICK_CUSTOM_INCLUDE <span class="meta-string">&quot;Arduino.h&quot;</span>         <span class="comment">/*Header for the system time function*/</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> LV_TICK_CUSTOM_SYS_TIME_EXPR (millis())    <span class="comment">/*Expression evaluating to current system time in ms*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>   <span class="comment">/*LV_TICK_CUSTOM*/</span></span></span><br></pre></td></tr></table></figure><p>stm32使用硬件timer</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">HardwareTimer *MyTim;</span><br><span class="line">    <span class="comment">/*Initialize the graphics library&#x27;s tick*/</span></span><br><span class="line">    MyTim = <span class="keyword">new</span> HardwareTimer(TIM2);</span><br><span class="line">    MyTim-&gt;setMode(<span class="number">2</span>, TIMER_OUTPUT_COMPARE);  <span class="comment">// In our case, channekFalling is configured but not really used. Nevertheless it would be possible to attach a callback to channel compare match.</span></span><br><span class="line">    MyTim-&gt;setOverflow(<span class="number">1000</span>/LVGL_TICK_PERIOD, HERTZ_FORMAT); <span class="comment">// period in Hz</span></span><br><span class="line">    MyTim-&gt;attachInterrupt(lv_tick_handler);</span><br><span class="line">    MyTim-&gt;resume();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lv_tick_handler</span><span class="params">(HardwareTimer*)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    lv_tick_inc(LVGL_TICK_PERIOD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>linux等使用 mingw标准库   &lt;stddef.h&gt;  里的宏定义  sys_time</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !LV_TICK_CUSTOM</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * You have to call this function periodically</span></span><br><span class="line"><span class="comment"> * @param tick_period the call period of this function in milliseconds</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">LV_ATTRIBUTE_TICK_INC <span class="keyword">void</span> <span class="title">lv_tick_inc</span><span class="params">(<span class="keyword">uint32_t</span> tick_period)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tick_irq_flag = <span class="number">0</span>;</span><br><span class="line">    sys_time += tick_period;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="第二步-核心初始化"><a href="#第二步-核心初始化" class="headerlink" title="第二步 核心初始化"></a>第二步 核心初始化</h2><p>lv核心初始化 完成各种结构体与函数的初始化   </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_init();</span><br></pre></td></tr></table></figure><h2 id="第三步-硬件抽象层"><a href="#第三步-硬件抽象层" class="headerlink" title="第三步  硬件抽象层"></a>第三步  硬件抽象层</h2><p>硬件虚拟层需要 完成  display, input devices, tick     也就是与驱动的对接，与输入设备的对接   完成tick （节拍）？</p><h3 id="1-先看display"><a href="#1-先看display" class="headerlink" title="1 先看display"></a>1 先看display</h3><ul><li><p>先实例化底层显示驱动    </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SDL驱动      monitor_init();</span><br><span class="line"></span><br><span class="line">TFT espi驱动      tft.begin();          <span class="comment">/* TFT init TFT初始化*/</span> </span><br><span class="line">tft.setRotation( <span class="number">1</span> ); <span class="comment">/* Landscape orientation, flipped 设置方向*/</span></span><br></pre></td></tr></table></figure></li><li><p>创造缓冲区</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Create a display buffer  SDL样式的*/</span>  </span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">lv_disp_draw_buf_t</span> disp_buf1;</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">lv_color_t</span> buf1_1[<span class="number">480</span> * <span class="number">10</span>];</span><br><span class="line">   lv_disp_draw_buf_init(&amp;disp_buf1, buf1_1, <span class="literal">NULL</span>, <span class="number">480</span> * <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">lv_disp_buf_init(&amp;disp_buf, buf, <span class="literal">NULL</span>, LV_HOR_RES_MAX * <span class="number">10</span>);</span><br></pre></td></tr></table></figure><ul><li>完成display到实际底层驱动的填充函数</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Display flushing 显示填充  espi样式  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_disp_flush</span><span class="params">( <span class="keyword">lv_disp_drv_t</span> *disp, <span class="keyword">const</span> <span class="keyword">lv_area_t</span> *area, <span class="keyword">lv_color_t</span> *color_p )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> w = ( area-&gt;x2 - area-&gt;x1 + <span class="number">1</span> );</span><br><span class="line">    <span class="keyword">uint32_t</span> h = ( area-&gt;y2 - area-&gt;y1 + <span class="number">1</span> );</span><br><span class="line"></span><br><span class="line">    tft.startWrite();</span><br><span class="line">    tft.setAddrWindow( area-&gt;x1, area-&gt;y1, w, h );</span><br><span class="line">    tft.pushColors( ( <span class="keyword">uint16_t</span> * )&amp;color_p-&gt;full, w * h, <span class="literal">true</span> );</span><br><span class="line">    tft.endWrite();</span><br><span class="line"></span><br><span class="line">    lv_disp_flush_ready( disp );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>直接写GRAM样式</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_disp_flush</span><span class="params">(<span class="keyword">lv_disp_drv_t</span> *disp, <span class="keyword">const</span> <span class="keyword">lv_area_t</span> *area, <span class="keyword">lv_color_t</span> *color_p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    u16 height,width;</span><br><span class="line">    u16 i,j;</span><br><span class="line">    width=area-&gt;x2 - area-&gt;x1+<span class="number">1</span>;             <span class="comment">//得到填充的宽度</span></span><br><span class="line">    height=area-&gt;y2 - area-&gt;y1+<span class="number">1</span>;            <span class="comment">//高度</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;height;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        LCD_SetCursor(area-&gt;x1,area-&gt;y1+i);       <span class="comment">//设置光标位置</span></span><br><span class="line">        LCD_WriteRAM_Prepare();     <span class="comment">//开始写入GRAM</span></span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;width;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            LCD_TYPE-&gt;LCD_RAM=color_p-&gt;full;<span class="comment">//写入数据</span></span><br><span class="line">            color_p++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    lv_disp_flush_ready(disp); <span class="comment">/* tell lvgl that flushing is done */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>SDL样式</li></ul><p>monitor_flush</p><p>创造display</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Initialize the display初始化display*/</span></span><br><span class="line">   <span class="keyword">lv_disp_drv_t</span> disp_drv;</span><br><span class="line">   lv_disp_drv_init(&amp;disp_drv);</span><br><span class="line">   disp_drv.hor_res = LV_HOR_RES_MAX;</span><br><span class="line">   disp_drv.ver_res = LV_VER_RES_MAX;</span><br><span class="line">   disp_drv.flush_cb = my_disp_flush;<span class="comment">//  这里就用到了填充函数</span></span><br><span class="line">   disp_drv.buffer = &amp;disp_buf;</span><br><span class="line">   lv_disp_drv_register(&amp;disp_drv);</span><br></pre></td></tr></table></figure><h3 id="2-再看输入层"><a href="#2-再看输入层" class="headerlink" title="2 再看输入层"></a>2 再看输入层</h3><ul><li>先初始化硬件接口</li></ul><p>TFT-esp 这样 触摸屏</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint16_t</span> calData[<span class="number">5</span>] = &#123; <span class="number">187</span>, <span class="number">3596</span>, <span class="number">387</span>, <span class="number">3256</span>, <span class="number">5</span> &#125;;</span><br><span class="line">tft.setTouch( calData ); <span class="comment">// espi如果设置了touch cs 自动完成触摸的初始化</span></span><br></pre></td></tr></table></figure><p> 独立的xpt2046驱动 触摸屏</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">XPT2046_Touchscreen <span class="title">ts</span><span class="params">(CS_PIN, irq_pin)</span></span>;</span><br></pre></td></tr></table></figure><p> 模拟器的鼠标键盘</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mouse_init();<span class="comment">//在模拟器里也完成了触摸回调函数</span></span><br></pre></td></tr></table></figure><p>其他的滚轮键盘编码器也同样原理</p><h3 id="对接触摸驱动-完成触摸回调函数"><a href="#对接触摸驱动-完成触摸回调函数" class="headerlink" title="对接触摸驱动 完成触摸回调函数"></a>对接触摸驱动 完成触摸回调函数</h3><p>espi</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Read the touchpad*/</span></span><br><span class="line"><span class="comment">/*读取触摸板*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_touchpad_read</span><span class="params">( <span class="keyword">lv_indev_drv_t</span> * indev_driver, <span class="keyword">lv_indev_data_t</span> * data )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint16_t</span> touchX, touchY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> touched = tft.getTouch( &amp;touchX, &amp;touchY, <span class="number">600</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( !touched )</span><br><span class="line">    &#123;</span><br><span class="line">        data-&gt;state = LV_INDEV_STATE_REL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        data-&gt;state = LV_INDEV_STATE_PR;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*Set the coordinates*/</span></span><br><span class="line">        data-&gt;point.x = touchX;</span><br><span class="line">        data-&gt;point.y = touchY;</span><br><span class="line"></span><br><span class="line">        Serial.print( <span class="string">&quot;Data x &quot;</span> );</span><br><span class="line">        Serial.println( touchX );</span><br><span class="line"></span><br><span class="line">        Serial.print( <span class="string">&quot;Data y &quot;</span> );</span><br><span class="line">        Serial.println( touchY );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>xpt2046</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">my_touchpad_read</span><span class="params">(<span class="keyword">lv_indev_drv_t</span> * indev, <span class="keyword">lv_indev_data_t</span> * data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">lv_coord_t</span> last_x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">lv_coord_t</span> last_y = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*Save the state and save the pressed coordinate*/</span></span><br><span class="line">    data-&gt;state = ts.touched() ? LV_INDEV_STATE_PR : LV_INDEV_STATE_REL;</span><br><span class="line">    <span class="keyword">if</span>(data-&gt;state == LV_INDEV_STATE_PR)&#123;</span><br><span class="line">        TS_Point p = ts.getPoint();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//convert to lcd position</span></span><br><span class="line">        last_x = LV_HOR_RES-(p.x *LV_HOR_RES)/<span class="number">4095</span>;       <span class="comment">/*TODO save the current X coordinate*/</span></span><br><span class="line">        last_y = LV_VER_RES-(p.y *LV_VER_RES)/<span class="number">4095</span>;       <span class="comment">/*TODO save the current Y coordinate*/</span></span><br><span class="line">        </span><br><span class="line">        Serial.print(<span class="string">&quot;touched:&quot;</span>);</span><br><span class="line">        Serial.print(last_x);Serial.print(<span class="string">&quot;,&quot;</span>);Serial.println(last_y);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/*Set the coordinates (if released use the last pressed coordinates)*/</span></span><br><span class="line">    data-&gt;point.x = last_x;</span><br><span class="line">    data-&gt;point.y = last_y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">/*Return `false` because we are not buffering and no more data to read*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完成lvgl输入驱动与硬件驱动的对接"><a href="#完成lvgl输入驱动与硬件驱动的对接" class="headerlink" title="完成lvgl输入驱动与硬件驱动的对接"></a>完成lvgl输入驱动与硬件驱动的对接</h3><p>触摸样式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Initialize the (dummy) input device driver*/</span></span><br><span class="line"><span class="comment">/*初始化（虚拟）输入设备驱动程序*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">lv_indev_drv_t</span> indev_drv;</span><br><span class="line">lv_indev_drv_init( &amp;indev_drv );</span><br><span class="line">indev_drv.type = LV_INDEV_TYPE_POINTER;</span><br><span class="line">indev_drv.read_cb = my_touchpad_read;<span class="comment">//上一步的在这用到了</span></span><br><span class="line">lv_indev_drv_register( &amp;indev_drv );</span><br></pre></td></tr></table></figure><p>模拟器样式 使用鼠标</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Add the mouse as input device</span></span><br><span class="line"><span class="comment">  * Use the &#x27;mouse&#x27; driver which reads the PC&#x27;s mouse*/</span></span><br><span class="line"> mouse_init();</span><br><span class="line"> <span class="keyword">lv_indev_drv_t</span> indev_drv;</span><br><span class="line"> lv_indev_drv_init(&amp;indev_drv);          <span class="comment">/*Basic initialization*/</span></span><br><span class="line"> indev_drv.type = LV_INDEV_TYPE_POINTER;</span><br><span class="line"> indev_drv.read_cb = mouse_read;         <span class="comment">/*This function will be called periodically (by the library) to get the mouse position and state*/</span></span><br><span class="line"> <span class="keyword">lv_indev_t</span> * mouse_indev = lv_indev_drv_register(&amp;indev_drv);</span><br></pre></td></tr></table></figure><h2 id="3-初始化节拍"><a href="#3-初始化节拍" class="headerlink" title="3 初始化节拍"></a>3 初始化节拍</h2><p>arduino 自动完成此步骤</p><p>模拟器</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Tick init.</span></span><br><span class="line"><span class="comment"> * You have to call &#x27;lv_tick_inc()&#x27; in periodically to inform LittelvGL about how much time were elapsed</span></span><br><span class="line"><span class="comment"> * Create an SDL thread to do this*/</span></span><br><span class="line">SDL_CreateThread(tick_thread, <span class="string">&quot;tick&quot;</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>stm32</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Initialize the graphics library&#x27;s tick*/</span></span><br><span class="line">MyTim = <span class="keyword">new</span> HardwareTimer(TIM2);</span><br><span class="line">MyTim-&gt;setMode(<span class="number">2</span>, TIMER_OUTPUT_COMPARE);  <span class="comment">// In our case, channekFalling is configured but not really used. Nevertheless it would be possible to attach a callback to channel compare match.</span></span><br><span class="line">MyTim-&gt;setOverflow(<span class="number">1000</span>/LVGL_TICK_PERIOD, HERTZ_FORMAT); <span class="comment">// period in Hz</span></span><br><span class="line">MyTim-&gt;attachInterrupt(lv_tick_handler);</span><br><span class="line">MyTim-&gt;resume();</span><br></pre></td></tr></table></figure><p>说实话我没怎么看懂</p><h1 id="第三步-开始绘制gui"><a href="#第三步-开始绘制gui" class="headerlink" title="第三步 开始绘制gui"></a>第三步 开始绘制gui</h1><p>硬件抽象层完成初始化  就可以开始绘制ui</p><p>第一步是初始化sceen</p><p>从sceen里创建各种widget  给widget添加事件回调 然后在无线循环里调用lv_timer_handler()，它会按LVGL_TICK_PERIOD 设置的事件重复的响应输入事件来重绘ui</p><p>这里简单绘制个label，注意label默认不带事件。除非用函数强制开启</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Create a Label on the currently active screen在当前屏幕上生成一个label*/</span></span><br></pre></td></tr></table></figure><p>　　static  lv_obj_t * label1&#x3D; lv_label_create(lv_scr_act());&#x2F;&#x2F; lv_sce_act()可以获得当前屏幕  使用静态指针是避免setup函数结束后指针被释放找不到对象自己</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*Modify the Label&#39;s text设置文本*&#x2F;</span><br><span class="line">    lv_label_set_text(label1, &quot;Hello world!&quot;);</span><br><span class="line">    </span><br><span class="line">    lv_obj_set_pos(label1, 0, 2);</span><br><span class="line"></span><br><span class="line">    &#x2F;* Align the Label to the center</span><br><span class="line">     * NULL means align on parent (which is the screen now)</span><br><span class="line">     * 0, 0 at the end means an x, y offset after alignment*&#x2F;</span><br><span class="line">&#x2F;&#x2F; </span><br></pre></td></tr></table></figure><p>添加一个带事件的按钮 </p><p> 这里我一开始尝试用模拟器，但是guiguider跟lvgl是是纯c语言的 不支持 c++的String，但是c想实现字符串的动态增长可是无比蛋疼的 这时候arduino的C++特性就很好用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">btn_event_cb</span><span class="params">(<span class="keyword">lv_event_t</span> * e)</span><span class="comment">//回调函数都是静态的 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">lv_event_code_t</span> code = lv_event_get_code(e);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​    <span class="keyword">if</span>(code == LV_EVENT_CLICKED) &#123;</span><br><span class="line"></span><br><span class="line">​      <span class="keyword">static</span> String temp = lv_label_get_text(label);<span class="comment">//临时变量也是静态的</span></span><br><span class="line"></span><br><span class="line">​      temp = temp + <span class="string">&quot;!&quot;</span>;</span><br><span class="line"></span><br><span class="line">​      lv_label_set_text(label1,  temp.c_str());</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lv_obj_t</span> * btn = lv_btn_create(lv_scr_act());     <span class="comment">/*Add a button the current screen*/</span></span><br><span class="line">lv_obj_set_pos(btn, <span class="number">50</span>, <span class="number">50</span>);                            <span class="comment">/*Set its position*/</span></span><br><span class="line">lv_obj_set_size(btn, <span class="number">120</span>, <span class="number">50</span>);                          <span class="comment">/*Set its size*/</span></span><br><span class="line">lv_obj_add_event_cb(btn, btn_event_cb, LV_EVENT_ALL, <span class="literal">NULL</span>);           <span class="comment">/*Assign a callback to the button*/</span></span><br></pre></td></tr></table></figure><hr><h1 id="相关链接-侵删"><a href="#相关链接-侵删" class="headerlink" title="相关链接(侵删)"></a>相关链接(侵删)</h1><ol><li><a href="https://www.cnblogs.com/kyo413/p/16608162.html">分析lvgl的代码启动过程，对比esp32，stm32，linux</a></li></ol><hr><center><font color=red>=================我是分割线=================</font></center><p><strong>欢迎到公众号来唠嗑:</strong></p><img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">]]></content>
    
    
    <summary type="html">LVGL基本启动过程</summary>
    
    
    
    <category term="编程类" scheme="https://zml3589110.github.io/categories/%E7%BC%96%E7%A8%8B%E7%B1%BB/"/>
    
    <category term="C" scheme="https://zml3589110.github.io/categories/%E7%BC%96%E7%A8%8B%E7%B1%BB/C/"/>
    
    <category term="GUI" scheme="https://zml3589110.github.io/categories/GUI/"/>
    
    <category term="LVGL" scheme="https://zml3589110.github.io/categories/LVGL/"/>
    
    
    <category term="linux" scheme="https://zml3589110.github.io/tags/linux/"/>
    
    <category term="C" scheme="https://zml3589110.github.io/tags/C/"/>
    
    <category term="STM32" scheme="https://zml3589110.github.io/tags/STM32/"/>
    
    <category term="GUI" scheme="https://zml3589110.github.io/tags/GUI/"/>
    
    <category term="LVGL" scheme="https://zml3589110.github.io/tags/LVGL/"/>
    
    <category term="ESP32" scheme="https://zml3589110.github.io/tags/ESP32/"/>
    
  </entry>
  
  <entry>
    <title>ESP32使用SPI总线驱动LCD</title>
    <link href="https://zml3589110.github.io/posts/1827825660.html"/>
    <id>https://zml3589110.github.io/posts/1827825660.html</id>
    <published>2024-07-18T02:34:20.000Z</published>
    <updated>2024-07-18T02:52:58.853Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ST7789液晶屏开发"><a href="#ST7789液晶屏开发" class="headerlink" title="ST7789液晶屏开发"></a>ST7789液晶屏开发</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在前言里面我想告诉你一些在对一款新的处理器的学习中，我们会遇到的那些错误，并且我相信这绝对不会是我一个人会出现的问题，出现这种问题首先原因是处理器的教程不够全面，没有像stm32一样一套保姆级别的教程能够一点一点引导着大家去学习，第二个原因就是esp32更新版本很快，导致一些教程会因为大版本的更新而不能使用。这里我就想站在初学者的角度来进行一番探索，也希望大家看完我出错的的过程后能够有所启发。</p><h2 id="初次尝试"><a href="#初次尝试" class="headerlink" title="初次尝试"></a>初次尝试</h2><p>在学习一款处理器的过程中，如何连接外设，配置外设接口并且成功驱动外设是非常重要的，经过前面的学习，我们结合其他处理器的学习经验，例如stm32，再结合乐鑫官方的教程和示例工程，其实是很容易就能控制一些常规的GPIO口，USART，I2C接口的外设或者通信。</p><p> 但是在我学习到LCD屏幕时，却遇到了很大的阻碍，和往常一样，在我准备配置这块1.3寸的驱动为st7789的屏幕时，我照例打开乐鑫官方的编程指南<a href="https://docs.espressif.com/projects/esp-idf/zh_CN/latest/esp32/index.html">ESP-IDF 编程指南 - ESP32 - — ESP-IDF 编程指南 latest 文档 (espressif.com)</a>。</p><p>找到API参考，外设API，进而找到LCD这个目录，然后我就发现没有中文，这种情况我已经不是第一次遇到了，所以我很熟练的进行手册的版本切换，从原来的master版切换到v5.1.3版本，切换完成后我就看到它上面提示到最新稳定版是v5.2.1，所以我就又点击它切换到5.2.1版本。但是令人失望的是依旧没有出现我们想要的中文。那么我就明白了这一个说明大概率是没有中文的，但是没关系，英文版本我们一样看得懂，毕竟现在互联网这么发达，找到一个翻译实在是太容易了。</p><img src="/posts/undefined/dd1e1868604f49c2854c1d7009017cc3.png" class="" title="img"><p><strong>首先映入眼帘的就是功能概述了，我从中提取到三个关键信息</strong></p><img src="/posts/undefined/468568ea80d64db1b547a29ef878a501.png" class="" title="img"><ol><li>乐鑫提供了开箱即用的LCD驱动程序</li><li>有安装驱动程序的步骤</li><li>有控制LCD IO的API</li></ol><p>我这一看这不是妥了吗，基本上和之前GPIO，USART，I2C一样，按着官方的教程一步一步来，应该很轻松就能把这个屏幕初始化完成。殊不知这才是噩梦的开始。</p><h2 id="并没有找到驱动"><a href="#并没有找到驱动" class="headerlink" title="并没有找到驱动"></a>并没有找到驱动</h2><p>首先是即使乐鑫官方明说了有st7789的驱动程序，我也没有在乐鑫组件注册表中找到它，上面所提到的两款驱动，st7789和ssd1306，我只能搜索到ssd1306的驱动组件。但是这也无伤大雅，驱动组件中无非是定义着一些有关驱动的参数罢了，相关参数我们完全可以按照stm32开发时的流程，直接在st7789驱动的数据手册里面或者是商家给的驱动说明里面提取即可。</p><h2 id="初次尝试安装SPI-LCD-IO-驱动程序"><a href="#初次尝试安装SPI-LCD-IO-驱动程序" class="headerlink" title="初次尝试安装SPI LCD IO 驱动程序"></a>初次尝试安装SPI LCD IO 驱动程序</h2><p>然后就是去点击<a href="https://docs.espressif.com/projects/esp-idf/zh_CN/v5.2.1/esp32/api-reference/peripherals/lcd.html#spi-lcd-panel">SPI Interfaced LCD</a>链接进入安装SPI LCD IO 驱动程序然后获取面板句柄的步骤的页面，实际上这些内容就在下面，直接向下滚动就能够看到。</p><img src="/posts/undefined/631a4fc290534e5d81e3d808f48e3617.png" class="" title="img"><img src="/posts/undefined/084feadae0f1487593da11e225544202.png" class="" title="img"><img src="/posts/undefined/7f412e5074f343d1abb0b4c4531c9a16.png" class="" title="img"><p>我这一看，嚯，一二三步骤都标好了，这不就是我最需要的吗，当时我心里还在想，乐鑫官方是真的贴心啊，学习成本大大降低了，之后就是我按照上面的三个步骤，进行我的SPI配置，先创建SPI总线，然后从 SPI 总线分配 LCD IO 设备句柄，最后就是安装液晶屏控制器驱动程序，一切都是那么的水到渠成。</p><h2 id="初次使用控制LCD-IO的API"><a href="#初次使用控制LCD-IO的API" class="headerlink" title="初次使用控制LCD IO的API"></a>初次使用控制LCD IO的API</h2><p> 依旧是点击<a href="https://docs.espressif.com/projects/esp-idf/zh_CN/v5.2.1/esp32/api-reference/peripherals/lcd.html#lcd-panel-operations">LCD 面板 IO 操作</a> 链接，转到下图界面</p><img src="/posts/undefined/f15c81856f9a46c692785fef6b1870ed.png" class="" title="img"><p>然后我选择了这三个看起来有用的初始化函数，进行一一调用。但是当我调用完成以后，我迷茫了，是的跟着手册一路配置加初始化到这里我不知道我该干什么了，按理说我们现在已经初始化完成了SPI和LCD的相关配置，接着就是收发数据了，但是我完全不知道该如何向LCD屏中发送数据，而手册中唯一和发送数据相关的就是esp_lcd_panel_draw_bitmap()函数，这个函数是将用户提供的颜色缓冲区绘制到LCD屏幕上。</p><p>当时我没有感觉到又哪里不对，心里想的是这不就是个画点函数，有了画点函数我不随便编写其他的绘画函数。所以当时我选择了先编译一下程序看看，一方面是想看初始化完成后到底是个什么情况，另一方面也是要确定我的程序确实没有问题能够运行起来。</p><p>很成功，在解决了编译时出现的小问题后，程序编译成功并且也烧录成功了，但是屏幕这个时候并没有点亮。在了解到初始化完成后屏幕也不会点亮，必须手动填充色块的相关情况后，我决定使用esp_lcd_panel_draw_bitmap()这个函数来试着填充一下屏幕区域，但是这时候我发现了另外的问题，虽然这个函数的参数和画点函数比较相似，都是传递起始坐标和结束坐标，另外就是传递一个颜色指针。但是我如果想填满整个屏幕，我就需要定义一个240x240大小的数组，并且我还要给他填充数据，这也太傻鸟了吧，我在心里忍不住吐槽。于是我就想着只填充几行看看效果就行，定义了一个20x20的数组，将数组的地址传递进去之后，按照它这函数的作用，应该是会显示一个小方块，不过经过我重新烧录验证，屏幕依旧是是没有任何反应。20的数组，将数组的地址传递进去之后，按照它这函数的作用，应该是会显示一个小方块，不过经过我重新烧录验证，屏幕依旧是是没有任何反应。</p><p>到这里我就开始怀疑我的程序到底是不是有问题了，于是我不再局限于官方的编程手册，转而到网络上搜索相关的教程，事实证明我这一步决策是十分正确的，网上的相关教程确实补充了我之前根据官方编程手册的一些不足之处（实际上也是官方的另外的教程罢了）。</p><h2 id="二次尝试"><a href="#二次尝试" class="headerlink" title="二次尝试"></a>二次尝试</h2><p>由于大部分人使用esp32做项目都是用Arduino这个开发环境，所以我在搜索教程时也遇到了一定困难，中间具体的搜索过程我就不细说了，直接讲最后的搜索结果，我在bilibili上找到了一个用esp-idf移植驱动一块触摸屏的教程，起初一段我觉得这个教程讲的十分的详细，所以第二次我就完全按照这个教程来进行学习<a href="https://www.bilibili.com/video/BV1Yc411y7bb/?spm_id_from=333.999.0.0&vd_source=ba7ed6e0e74823b6b98addc6136682c2">ESP32-S3 开发 SPI 屏【DIY 智能手表】_哔哩哔哩_bilibili</a>。</p><p>依照这个教程，我们再次找到了另外的LCD官方教程<a href="https://docs.espressif.com/projects/esp-iot-solution/zh_CN/latest/display/lcd/spi_lcd.html#id3">SPI LCD 详解 - - — ESP-IoT-Solution latest 文档 (espressif.com)</a>， 这次的教程相比之前详细了不少，经过阅读这篇教程（视频前面上其实也是参考了这个教程），我发现我在第一次尝试的时候没有初始化SPI总线 ，也没有配置LCD 驱动 IC 的初始化命令及参数。</p><img src="/posts/undefined/4cc1efee5ecc4d2b8ffa3ea096b05deb.png" class="" title="img"><p>所以根据视频上的流程，我对之前的代码进行了更改，最后呈现出一下状态，由于我没有使用官方的驱动配置头文件，没有想视频中一样修改一下其他同类型的驱动头文件，所以关于驱动头文件里面声明的结构体我直接放在了我自己的头文件当中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;bsp_spi_lcd.h&quot;</span></span></span><br><span class="line"><span class="comment">// static const char BACK_COLOR[240][240] ;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *TAG = <span class="string">&quot;st7789-example&quot;</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">st7789_lcd_init_cmd_t</span> lcd_init_cmds [] =&#123;</span><br><span class="line">    <span class="comment">/* &#123;cmd, &#123; data &#125;, data_size, delay_ms&#125; &quot;*/</span></span><br><span class="line">    <span class="comment">// &#123;0x36, (uint8_t [])&#123;0x00&#125;, 1, 0&#125;,</span></span><br><span class="line">    <span class="comment">// &#123;0x3A, (uint8_t [])&#123;0x05&#125;, 1, 0&#125;,</span></span><br><span class="line">    &#123;<span class="number">0xB2</span>, (<span class="keyword">uint8_t</span> [])&#123;<span class="number">0x0C</span>,<span class="number">0x0C</span>,<span class="number">0x00</span>,<span class="number">0x33</span>,<span class="number">0x33</span>&#125;, <span class="number">5</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0xB7</span>, (<span class="keyword">uint8_t</span> [])&#123;<span class="number">0x35</span>&#125;, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0xBB</span>, (<span class="keyword">uint8_t</span> [])&#123;<span class="number">0x19</span>&#125;, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0xC0</span>, (<span class="keyword">uint8_t</span> [])&#123;<span class="number">0x2C</span>&#125;, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0xC2</span>, (<span class="keyword">uint8_t</span> [])&#123;<span class="number">0x01</span>&#125;, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0xC3</span>, (<span class="keyword">uint8_t</span> [])&#123;<span class="number">0x12</span>&#125;, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0xC4</span>, (<span class="keyword">uint8_t</span> [])&#123;<span class="number">0x20</span>&#125;, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0xC6</span>, (<span class="keyword">uint8_t</span> [])&#123;<span class="number">0x0F</span>&#125;, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0xD0</span>, (<span class="keyword">uint8_t</span> [])&#123;<span class="number">0xA4</span>,<span class="number">0xA1</span>&#125;, <span class="number">2</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0xE0</span>, (<span class="keyword">uint8_t</span> [])&#123;<span class="number">0xD0</span>,<span class="number">0x04</span>,<span class="number">0x0D</span>,<span class="number">0x11</span>,<span class="number">0x13</span>,<span class="number">0x2B</span>,<span class="number">0x3F</span>,<span class="number">0x54</span>,<span class="number">0x4C</span>,<span class="number">0x18</span>,<span class="number">0x0D</span>,<span class="number">0x0B</span>,<span class="number">0x1F</span>,<span class="number">0x23</span>&#125;, <span class="number">14</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0xE1</span>, (<span class="keyword">uint8_t</span> [])&#123;<span class="number">0xD0</span>,<span class="number">0x04</span>,<span class="number">0x0C</span>,<span class="number">0x11</span>,<span class="number">0x13</span>,<span class="number">0x2C</span>,<span class="number">0x3F</span>,<span class="number">0x44</span>,<span class="number">0x51</span>,<span class="number">0x2F</span>,<span class="number">0x1F</span>,<span class="number">0x1F</span>,<span class="number">0x20</span>,<span class="number">0x23</span>&#125;, <span class="number">14</span>, <span class="number">0</span>&#125;,</span><br><span class="line"> </span><br><span class="line">    &#123;<span class="number">0x21</span>, (<span class="keyword">uint8_t</span> [])&#123;<span class="number">0x00</span>&#125;, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0x11</span>, (<span class="keyword">uint8_t</span> [])&#123;<span class="number">0x00</span>&#125;, <span class="number">1</span>, <span class="number">120</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0x29</span>, (<span class="keyword">uint8_t</span> [])&#123;<span class="number">0x00</span>&#125;, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0x2A</span>, (<span class="keyword">uint8_t</span> [])&#123;<span class="number">0x00</span>&#125;, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0x2B</span>, (<span class="keyword">uint8_t</span> [])&#123;<span class="number">0x00</span>&#125;, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0x2C</span>, (<span class="keyword">uint8_t</span> [])&#123;<span class="number">0x00</span>&#125;, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//初始化接口设备</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Lcd_Init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">esp_lcd_panel_io_handle_t</span> io_handle = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">esp_lcd_panel_handle_t</span> panel_handle = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// static lv_disp_draw_buf_t disp_buf;</span></span><br><span class="line">    <span class="comment">// static lv_disp_drv_t disp_drv;</span></span><br><span class="line"> </span><br><span class="line">     <span class="comment">/***************************************** 1.初始化总线 **************************************************/</span></span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;Initialize SPI bus&quot;</span>);</span><br><span class="line">    <span class="keyword">spi_bus_config_t</span> buscfg = &#123;</span><br><span class="line">        .sclk_io_num = PIN_NUM_CLK,   <span class="comment">// 连接 LCD SCK（SCL） 信号的 IO 编号</span></span><br><span class="line">        .mosi_io_num = PIN_NUM_MOSI,  <span class="comment">// 连接 LCD MOSI（SDO、SDA） 信号的 IO 编号</span></span><br><span class="line">        .miso_io_num = <span class="number">-1</span>,  <span class="comment">// 连接 LCD MISO（SDI） 信号的 IO 编号，如果不需要从 LCD 读取数据，可以设为 `-1`</span></span><br><span class="line">        .quadwp_io_num = <span class="number">-1</span>,          <span class="comment">// 必须设置且为 `-1`</span></span><br><span class="line">        .quadhd_io_num = <span class="number">-1</span>,          <span class="comment">// 必须设置且为 `-1`</span></span><br><span class="line">        .max_transfer_sz = LCD_H_RES * LCD_W_RES * <span class="keyword">sizeof</span>(<span class="keyword">uint16_t</span>), <span class="comment">// 表示 SPI 单次传输允许的最大字节数上限，通常设为全屏大小即可</span></span><br><span class="line">    &#125;;</span><br><span class="line">    ESP_ERROR_CHECK(spi_bus_initialize(SPI3_HOST, &amp;buscfg, SPI_DMA_CH_AUTO));</span><br><span class="line">                                          <span class="comment">// 第 1 个参数表示使用的 SPI 主机 ID，和后续创建接口设备时保持一致</span></span><br><span class="line">                                          <span class="comment">// 第 3 个参数表示使用的 DMA 通道号，默认设置为 `SPI_DMA_CH_AUTO` 即可</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/****************************************** 2.创建接口设备 **************************************************/</span></span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;Install panel IO&quot;</span>);</span><br><span class="line">    <span class="keyword">esp_lcd_panel_io_spi_config_t</span> io_config = &#123;</span><br><span class="line">        .dc_gpio_num = PIN_NUM_DC,</span><br><span class="line">        .cs_gpio_num = <span class="number">-1</span>,       <span class="comment">// 连接 LCD CS 信号的 IO 编号，可以设为 `-1` 表示不使用</span></span><br><span class="line">        .pclk_hz = LCD_PIXEL_CLOCK_HZ,           <span class="comment">//Clock out at 20 MHz</span></span><br><span class="line">        .lcd_cmd_bits = LCD_CMD_BITS,       <span class="comment">// 单位 LCD 命令的比特数，应为 8 的整数倍</span></span><br><span class="line">        .lcd_param_bits = LCD_PARAM_BITS,   <span class="comment">// 单位 LCD 参数的比特数，应为 8 的整数倍</span></span><br><span class="line">        .spi_mode = <span class="number">3</span>,         <span class="comment">// SPI 模式（0-3），需根据 LCD 驱动 IC 的数据手册以及硬件的配置确定（如 IM[3:0]）</span></span><br><span class="line">        .trans_queue_depth = <span class="number">10</span>,        <span class="comment">// SPI 设备传输数据的队列深度，一般设为 10 即可</span></span><br><span class="line">        <span class="comment">// .on_color_trans_done = example_notify_lvgl_flush_ready,   // 单次调用 `esp_lcd_panel_draw_bitmap()` 传输完成后的回调函数</span></span><br><span class="line">        <span class="comment">// .user_ctx = &amp;disp_drv,</span></span><br><span class="line">        .flags = &#123;            <span class="comment">// 以下为 SPI 时序的相关参数，需根据 LCD 驱动 IC 的数据手册以及硬件的配置确定</span></span><br><span class="line">            .sio_mode = <span class="number">0</span>,    <span class="comment">// 通过一根数据线（MOSI）读写数据，0: Interface I 型，1: Interface II 型</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// Attach the LCD to the SPI bus</span></span><br><span class="line">    ESP_ERROR_CHECK(esp_lcd_new_panel_io_spi((<span class="keyword">esp_lcd_spi_bus_handle_t</span>)SPI3_HOST, &amp;io_config, &amp;io_handle));</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/***************************************** 3.创建 LCD 设备 ***************************************************/</span></span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;Install ST7789 panel driver&quot;</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">st7789_vendor_config_t</span> vendor_config = &#123;  <span class="comment">// 用于替换驱动组件中的初始化命令及参数</span></span><br><span class="line">        .init_cmds = lcd_init_cmds,</span><br><span class="line">        .init_cmds_size = <span class="keyword">sizeof</span>(lcd_init_cmds) / <span class="keyword">sizeof</span>(<span class="keyword">st7789_lcd_init_cmd_t</span>),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">esp_lcd_panel_dev_config_t</span> panel_config = &#123;</span><br><span class="line">        .reset_gpio_num = PIN_NUM_RES,    <span class="comment">// 连接 LCD 复位信号的 IO 编号，可以设为 `-1` 表示不使用</span></span><br><span class="line">        .rgb_ele_order = LCD_RGB_ELEMENT_ORDER_RGB,   <span class="comment">// 像素色彩的元素顺序（RGB/BGR），</span></span><br><span class="line">                                                    <span class="comment">//  一般通过命令 `LCD_CMD_MADCTL（36h）` 控制</span></span><br><span class="line">        .bits_per_pixel = <span class="number">16</span>,  <span class="comment">// 色彩格式的位数（RGB565：16，RGB666：18），</span></span><br><span class="line">                                                    <span class="comment">// 一般通过命令 `LCD_CMD_COLMOD（3Ah）` 控制</span></span><br><span class="line">        .vendor_config = &amp;vendor_config,           <span class="comment">// 用于替换驱动组件中的初始化命令及参数</span></span><br><span class="line">    &#125;;</span><br><span class="line">    ESP_ERROR_CHECK(esp_lcd_new_panel_st7789(io_handle, &amp;panel_config, &amp;panel_handle));</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/****************************************** 4.初始化 LCD 设备 *************************************************/</span></span><br><span class="line">    ESP_ERROR_CHECK(esp_lcd_panel_reset(panel_handle));</span><br><span class="line">    ESP_ERROR_CHECK(esp_lcd_panel_init(panel_handle));</span><br><span class="line">    ESP_ERROR_CHECK(esp_lcd_panel_disp_on_off(panel_handle, <span class="literal">true</span>));</span><br><span class="line">    <span class="comment">// esp_lcd_panel_draw_bitmap(panel_handle,0,0,240,240,BACK_COLOR);</span></span><br></pre></td></tr></table></figure><p>当我完成上述代码后，由于视频中是触摸屏，并且还要移植LVGL图形界面，但是我现在还不想一步到位，我只想先实现屏幕能够点亮，能够显示静态的文字跟图片，所以视频后面关于配置触屏I2C以及LVGL的移植代码我就并没有添加。</p><p>到了这一步应该是配置已经事无巨细了，可实际当我满怀信息的去烧录完成等着屏幕点亮，却让我异常失望，屏幕并没有亮，这不禁让我怀疑我的屏是不是有问题。这个想法一下子就让我闻到了成功的气息，而问题的转折点也就出现在这里。</p><h2 id="最终尝试"><a href="#最终尝试" class="headerlink" title="最终尝试"></a>最终尝试</h2><p>为了测试我的屏幕是否有问题，我使用了商家给的代码，并且把代码移植到我自己的F103C8T6程序上，结果是能够使用商家的程序成功点亮这块屏幕，看着keil中熟悉的代码，然后我就有了新的想法，我们不要使用乐鑫教程中普遍使用的官方的配置函数，而是自己通过SPI总线向stm32中一样配置发送命令，发送数据的函数，然后所有的流程都严格依照32中的流程进行，这样不就能够可行了吗。</p><p><strong>所以我最后抛弃掉了所有的教程，开始了自己对32控制lcd屏幕的流程的完全移植，到了最后我重要是功夫不负有心人，在第一次尝试后的第二天完成了屏幕点亮。</strong></p><h1 id="正片"><a href="#正片" class="headerlink" title="正片"></a>正片</h1><h2 id="配置SPI控制器"><a href="#配置SPI控制器" class="headerlink" title="配置SPI控制器"></a>配置SPI控制器</h2><p>由于屏幕使用了SPI协议进行通信，那么我们点亮屏幕的第一步就是配置SPI，这一段在我们之前尝试的时候都有提到，我把代码放在这里，相信大家看到代码后就能理解这一环节到底在做些什么：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIN_NUM_MISO -1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIN_NUM_MOSI 23</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIN_NUM_CLK  18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIN_NUM_CS   -1</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vspi_init</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">spi_device_handle_t</span> spi;    <span class="comment">//创建spi</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">spi_bus_config_t</span> buscfg=&#123;   <span class="comment">//spi定义</span></span><br><span class="line">    .miso_io_num=PIN_NUM_MISO, </span><br><span class="line">    .mosi_io_num=PIN_NUM_MOSI,</span><br><span class="line">    .sclk_io_num=PIN_NUM_CLK,</span><br><span class="line">    .quadwp_io_num=<span class="number">-1</span>,</span><br><span class="line">    .quadhd_io_num=<span class="number">-1</span>,</span><br><span class="line">    .max_transfer_sz=<span class="number">4092</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">spi_device_interface_config_t</span> devcfg = &#123;</span><br><span class="line">    .clock_speed_hz = SPI_MASTER_FREQ_40M,</span><br><span class="line">    .mode = <span class="number">3</span>,</span><br><span class="line">    .spics_io_num   = PIN_NUM_CS,</span><br><span class="line">    .queue_size = <span class="number">7</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vspi_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    spi_bus_initialize(SPI3_HOST,&amp;buscfg,SPI_DMA_CH_AUTO);</span><br><span class="line">    spi_bus_add_device(SPI3_HOST, &amp;devcfg, &amp;spi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我稍微解释一下，大家可以看到我PIN_NUM_CS和PIN_NUM_MISO都定义为了-1，这是因为我们这块屏幕并没有使用这两根线，所以给-1表示不使用此功能。</p><h2 id="编写LCD屏幕初始化函数"><a href="#编写LCD屏幕初始化函数" class="headerlink" title="编写LCD屏幕初始化函数"></a>编写LCD屏幕初始化函数</h2><h3 id="LCD-Init"><a href="#LCD-Init" class="headerlink" title="LCD_Init"></a>LCD_Init</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*st7789*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LCD_Init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    esp_rom_gpio_pad_select_gpio(LCD_RES);   <span class="comment">//gpio_pad_select_gpio(LCD_RES)之前</span></span><br><span class="line">    esp_rom_gpio_pad_select_gpio(LCD_DC);   <span class="comment">//gpio_pad_select_gpio(LCD_DC)</span></span><br><span class="line">    gpio_set_direction(LCD_RES,GPIO_MODE_OUTPUT);    <span class="comment">//设置io22为输出模式</span></span><br><span class="line">    gpio_set_direction(LCD_DC,GPIO_MODE_OUTPUT);    <span class="comment">//设置io21为输出模式</span></span><br><span class="line"> </span><br><span class="line">vspi_init();</span><br><span class="line">LCD_RES_CLR();</span><br><span class="line">DELAY(<span class="number">20</span>);</span><br><span class="line">LCD_RES_SET();</span><br><span class="line">DELAY(<span class="number">20</span>);</span><br><span class="line"><span class="comment">//BLK_OFF();</span></span><br><span class="line"><span class="comment">// DELAY(100);</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// LCD_WR_REG(0x11); </span></span><br><span class="line"><span class="comment">// DELAY(120);</span></span><br><span class="line"> </span><br><span class="line">LCD_WR_REG(<span class="number">0x36</span>);</span><br><span class="line">LCD_WR_DATA8(<span class="number">0xc0</span>);</span><br><span class="line">LCD_WR_REG(<span class="number">0x3A</span>); </span><br><span class="line">LCD_WR_DATA8(<span class="number">0x05</span>);</span><br><span class="line"> </span><br><span class="line">LCD_WR_REG(<span class="number">0xB2</span>);</span><br><span class="line">LCD_WR_DATA8(<span class="number">0x0C</span>);</span><br><span class="line">LCD_WR_DATA8(<span class="number">0x0C</span>);</span><br><span class="line">LCD_WR_DATA8(<span class="number">0x00</span>);</span><br><span class="line">LCD_WR_DATA8(<span class="number">0x33</span>);</span><br><span class="line">LCD_WR_DATA8(<span class="number">0x33</span>); </span><br><span class="line"> </span><br><span class="line">LCD_WR_REG(<span class="number">0xB7</span>); </span><br><span class="line">LCD_WR_DATA8(<span class="number">0x35</span>);  </span><br><span class="line"> </span><br><span class="line">LCD_WR_REG(<span class="number">0xBB</span>);</span><br><span class="line">LCD_WR_DATA8(<span class="number">0x19</span>);</span><br><span class="line"> </span><br><span class="line">LCD_WR_REG(<span class="number">0xC0</span>);</span><br><span class="line">LCD_WR_DATA8(<span class="number">0x2C</span>);</span><br><span class="line"> </span><br><span class="line">LCD_WR_REG(<span class="number">0xC2</span>);</span><br><span class="line">LCD_WR_DATA8(<span class="number">0x01</span>);</span><br><span class="line"> </span><br><span class="line">LCD_WR_REG(<span class="number">0xC3</span>);</span><br><span class="line">LCD_WR_DATA8(<span class="number">0x12</span>);   </span><br><span class="line"> </span><br><span class="line">LCD_WR_REG(<span class="number">0xC4</span>);</span><br><span class="line">LCD_WR_DATA8(<span class="number">0x20</span>);  </span><br><span class="line"> </span><br><span class="line">LCD_WR_REG(<span class="number">0xC6</span>); </span><br><span class="line">LCD_WR_DATA8(<span class="number">0x0F</span>);    </span><br><span class="line"> </span><br><span class="line">LCD_WR_REG(<span class="number">0xD0</span>); </span><br><span class="line">LCD_WR_DATA8(<span class="number">0xA4</span>);</span><br><span class="line">LCD_WR_DATA8(<span class="number">0xA1</span>);</span><br><span class="line"> </span><br><span class="line">LCD_WR_REG(<span class="number">0xE0</span>);</span><br><span class="line">LCD_WR_DATA8(<span class="number">0xD0</span>);</span><br><span class="line">LCD_WR_DATA8(<span class="number">0x04</span>);</span><br><span class="line">LCD_WR_DATA8(<span class="number">0x0D</span>);</span><br><span class="line">LCD_WR_DATA8(<span class="number">0x11</span>);</span><br><span class="line">LCD_WR_DATA8(<span class="number">0x13</span>);</span><br><span class="line">LCD_WR_DATA8(<span class="number">0x2B</span>);</span><br><span class="line">LCD_WR_DATA8(<span class="number">0x3F</span>);</span><br><span class="line">LCD_WR_DATA8(<span class="number">0x54</span>);</span><br><span class="line">LCD_WR_DATA8(<span class="number">0x4C</span>);</span><br><span class="line">LCD_WR_DATA8(<span class="number">0x18</span>);</span><br><span class="line">LCD_WR_DATA8(<span class="number">0x0D</span>);</span><br><span class="line">LCD_WR_DATA8(<span class="number">0x0B</span>);</span><br><span class="line">LCD_WR_DATA8(<span class="number">0x1F</span>);</span><br><span class="line">LCD_WR_DATA8(<span class="number">0x23</span>);</span><br><span class="line"> </span><br><span class="line">LCD_WR_REG(<span class="number">0xE1</span>);</span><br><span class="line">LCD_WR_DATA8(<span class="number">0xD0</span>);</span><br><span class="line">LCD_WR_DATA8(<span class="number">0x04</span>);</span><br><span class="line">LCD_WR_DATA8(<span class="number">0x0C</span>);</span><br><span class="line">LCD_WR_DATA8(<span class="number">0x11</span>);</span><br><span class="line">LCD_WR_DATA8(<span class="number">0x13</span>);</span><br><span class="line">LCD_WR_DATA8(<span class="number">0x2C</span>);</span><br><span class="line">LCD_WR_DATA8(<span class="number">0x3F</span>);</span><br><span class="line">LCD_WR_DATA8(<span class="number">0x44</span>);</span><br><span class="line">LCD_WR_DATA8(<span class="number">0x51</span>);</span><br><span class="line">LCD_WR_DATA8(<span class="number">0x2F</span>);</span><br><span class="line">LCD_WR_DATA8(<span class="number">0x1F</span>);</span><br><span class="line">LCD_WR_DATA8(<span class="number">0x1F</span>);</span><br><span class="line">LCD_WR_DATA8(<span class="number">0x20</span>);</span><br><span class="line">LCD_WR_DATA8(<span class="number">0x23</span>);</span><br><span class="line"> </span><br><span class="line">LCD_WR_REG(<span class="number">0x21</span>); </span><br><span class="line">LCD_WR_REG(<span class="number">0x11</span>);</span><br><span class="line">LCD_WR_REG(<span class="number">0x29</span>);</span><br><span class="line"> </span><br><span class="line">LCD_Clear(<span class="number">0xFFFF</span>);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一步就是初始化LCD的最关键的步骤，就是发送命令配置屏幕的参数，这一部分基本上就是参考购买屏幕的商家给的示例程序来进行配置</p><p>可以看到我们在初始化的时候用到了发送命令和发送8位数据的函数，这需要我们自己编写，我这里的所有步骤都是基于对stm32的完全模仿，而且这也是我们初学esp32的最好方式，不要一上来就想着使用官方所提供好的功能函数，因为很可能你根本就搞不明白这些功能函数的到底有什么用处。</p><h3 id="LCD-WR-GER"><a href="#LCD-WR-GER" class="headerlink" title="LCD_WR_GER"></a>LCD_WR_GER</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LCD_WR_REG</span><span class="params">(<span class="keyword">uint8_t</span> dat)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LCD_DC_CLR();<span class="comment">//写命令</span></span><br><span class="line">lcd_cmd(dat);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LCD-WR-DATA8"><a href="#LCD-WR-DATA8" class="headerlink" title="LCD_WR_DATA8"></a>LCD_WR_DATA8</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LCD_WR_DATA8</span><span class="params">(<span class="keyword">uint8_t</span> dat)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LCD_DC_SET();<span class="comment">//写数据</span></span><br><span class="line">lcd_cmd(dat);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="lcd-cmd"><a href="#lcd-cmd" class="headerlink" title="lcd_cmd"></a>lcd_cmd</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lcd_cmd</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uint8_t</span> cmd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">esp_err_t</span> ret;</span><br><span class="line">    <span class="keyword">spi_transaction_t</span> t;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;t, <span class="number">0</span>, <span class="keyword">sizeof</span>(t));       <span class="comment">//Zero out the transaction</span></span><br><span class="line">    t.length=<span class="number">8</span>;                     <span class="comment">//Command is 8 bits</span></span><br><span class="line">    t.tx_buffer=&amp;cmd;               <span class="comment">//The data is the cmd itself</span></span><br><span class="line">    t.user=(<span class="keyword">void</span>*)<span class="number">0</span>;                <span class="comment">//D/C needs to be set to 0</span></span><br><span class="line">    ret=spi_device_polling_transmit(spi, &amp;t);  <span class="comment">//Transmit!</span></span><br><span class="line">    assert(ret==ESP_OK);            <span class="comment">//Should have had no issues.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们就是要解决最后第一个问题了，可以看到的是，我在LCD_Init中最后使用了一个清屏函数，只要我们想办法编写这个刷白函数，就能点亮屏幕，实现全屏颜色显示，而且在上面我们已经编写过传输8位指令或者数据的一个函数lcd_cmd，我们要使用这个函数的话就要循环调用240<em>240</em>2次lcd_cmd函数，这样做可以是可以但是有点拖拉，所以在这个函数的基础上，我们可以编写一个一次能够传送指定数据大小的函数:</p><h4 id="LCD-data-x"><a href="#LCD-data-x" class="headerlink" title="LCD_data_x"></a>LCD_data_x</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LCD_data_x</span><span class="params">(<span class="keyword">uint16_t</span> *dat,<span class="keyword">uint32_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">spi_transaction_t</span> t;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;t, <span class="number">0</span>, <span class="keyword">sizeof</span>(t));       <span class="comment">//Zero out the transaction</span></span><br><span class="line">    t.length=len;                     <span class="comment">//Command is 8 bits</span></span><br><span class="line">    t.tx_buffer=dat;               <span class="comment">//The data is the cmd itself</span></span><br><span class="line">    t.user=(<span class="keyword">void</span>*)<span class="number">0</span>;                <span class="comment">//D/C needs to be set to 0</span></span><br><span class="line">    <span class="keyword">esp_err_t</span> ret=spi_device_polling_transmit(spi, &amp;t);  <span class="comment">//Transmit!</span></span><br><span class="line">    assert(ret==ESP_OK);            <span class="comment">//Should have had no issues.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了这个函数，我们在编写清屏函数时就不用调用如此之多的lcd_cmd了，下面就是我对清屏函数的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LCD_Clear</span><span class="params">(<span class="keyword">uint16_t</span> Color)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LCD_Address_Set(<span class="number">0</span>,<span class="number">0</span>,LCD_W<span class="number">-1</span>,LCD_H<span class="number">-1</span>);</span><br><span class="line">LCD_DC_SET();<span class="comment">//写数据</span></span><br><span class="line"><span class="keyword">uint16_t</span> color_temp[<span class="number">240</span>*<span class="number">2</span>];</span><br><span class="line"><span class="built_in">memset</span>(color_temp, Color, <span class="keyword">sizeof</span>(color_temp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">uint16_t</span> i=<span class="number">0</span>;i&lt;LCD_W/<span class="number">2</span>;i++)&#123;</span><br><span class="line"> LCD_data_x(color_temp,<span class="number">240</span>*<span class="number">16</span>*<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现在清屏函数中我一次传输了两行的颜色数据，所以for循环中我只需要循环二分之一的屏幕宽度次就可以了，这样的操作相比于一次传输半个颜色数据在输出效率上会高一些，因为我们使用的16位颜色，但是之前的函数一次才传递8位，意味着我们一个颜色数据就要传输两次才能传输成功，现在这样就显然合理了很多。</p><p><strong>上面的函数里面我们用到了许多宏，这些我都把它放在了头文件中，在下面放出供大家参考使用：</strong></p><h4 id="LCD-Init-h"><a href="#LCD-Init-h" class="headerlink" title="LCD_Init.h"></a>LCD_Init.h</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LCD_W 240</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LCD_H 240</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LCD_RES GPIO_NUM_22</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LCD_DC  GPIO_NUM_21</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LCD_BLK GPIO_NUM_12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLK_ON()    gpio_set_level(LCD_BLK,1);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLK_OFF()   gpio_set_level(LCD_BLK,0);</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LCD_SCL_SET() gpio_set_level(LCD_SCL,1);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LCD_SCL_CLR() gpio_set_level(LCD_SCL,0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LCD_SDA_SET() gpio_set_level(LCD_SDA,1);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LCD_SDA_CLR() gpio_set_level(LCD_SDA,0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LCD_CS_SET() gpio_set_level(LCD_CS,1);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LCD_CS_CLR() gpio_set_level(LCD_CS,0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LCD_RES_SET() gpio_set_level(LCD_RES,1);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LCD_RES_CLR() gpio_set_level(LCD_RES,0);</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LCD_DC_SET() gpio_set_level(LCD_DC,1);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LCD_DC_CLR() gpio_set_level(LCD_DC,0);</span></span><br></pre></td></tr></table></figure><p>至此，大家可以在主函数中尽情的调用LCD_Init函数来对屏幕进行初始化了，相信初始化完成后，你们也能成功点亮自己LCD屏。</p><h2 id="基于-ESP32-的-LCD-模块（ST7789）开发"><a href="#基于-ESP32-的-LCD-模块（ST7789）开发" class="headerlink" title="基于 ESP32 的 LCD 模块（ST7789）开发"></a>基于 ESP32 的 LCD 模块（ST7789）开发</h2><img src="/posts/undefined/image-20240718105130913.png" class="" title="image-20240718105130913"><h3 id="初始化命令"><a href="#初始化命令" class="headerlink" title="初始化命令"></a>初始化命令</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">DRAM_ATTR <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">uint8_t</span> LCD_ORIENTATION_VALUES[]=&#123;</span><br><span class="line">    <span class="number">0x00</span>,   <span class="comment">// PORTRAIT</span></span><br><span class="line">    <span class="number">0xC0</span>,   <span class="comment">// PORTRAIT_INVERTED</span></span><br><span class="line">    <span class="number">0x70</span>,   <span class="comment">// LANDSCAPE</span></span><br><span class="line">    <span class="number">0xA0</span>    <span class="comment">// LANDSCAPE_INVERTED</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *LCD_ORIENTATION_TAGS[]=&#123;</span><br><span class="line">    <span class="string">&quot;PORTRAIT&quot;</span>,           <span class="comment">// 纵向</span></span><br><span class="line">    <span class="string">&quot;PORTRAIT_INVERTED&quot;</span>,  <span class="comment">// 纵向（颠倒）</span></span><br><span class="line">    <span class="string">&quot;LANDSCAPE&quot;</span>,          <span class="comment">// 横向</span></span><br><span class="line">    <span class="string">&quot;LANDSCAPE_INVERTED&quot;</span>  <span class="comment">// 横向（颠倒）</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LCD_WIDTH       240 <span class="comment">// LCD 宽度像素</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LCD_HEIGHT      240 <span class="comment">// LCD 高度像素</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  VIEW_ORIENTATION   0 <span class="comment">// LCD 方向 取值范围 0-3</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> cmd;</span><br><span class="line">    <span class="keyword">uint8_t</span> data[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">uint8_t</span> databytes;</span><br><span class="line">&#125; <span class="keyword">lcd_init_cmd_t</span>;</span><br><span class="line"></span><br><span class="line">DRAM_ATTR <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">lcd_init_cmd_t</span> LCD_INIT_CMDS[]=&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    &#123;<span class="number">0x36</span>, &#123;LCD_ORIENTATION_VALUES[VIEW_ORIENTATION]&#125;, <span class="number">1</span>&#125;,</span><br><span class="line">    <span class="comment">/* Interface Pixel Format, 16bits/pixel for RGB/MCU interface */</span></span><br><span class="line">    &#123;<span class="number">0x3A</span>, &#123;<span class="number">0x05</span>&#125;, <span class="number">1</span>&#125;,</span><br><span class="line">    <span class="comment">/* Porch Setting */</span></span><br><span class="line">    &#123;<span class="number">0xB2</span>, &#123;<span class="number">0x0c</span>, <span class="number">0x0c</span>, <span class="number">0x00</span>, <span class="number">0x33</span>, <span class="number">0x33</span>&#125;, <span class="number">5</span>&#125;,</span><br><span class="line">    <span class="comment">/* Gate Control, Vgh=13.65V, Vgl=-10.43V */</span></span><br><span class="line">    &#123;<span class="number">0xB7</span>, &#123;<span class="number">0x35</span>&#125;, <span class="number">1</span>&#125;,</span><br><span class="line">    <span class="comment">/* VCOM Setting, VCOM=1.35V */</span></span><br><span class="line">    &#123;<span class="number">0xBB</span>, &#123;<span class="number">0x32</span>&#125;, <span class="number">1</span>&#125;,</span><br><span class="line">    <span class="comment">/* VDV and VRH Command Enable, enable=1 */</span></span><br><span class="line">    &#123;<span class="number">0xC2</span>, &#123;<span class="number">0x01</span>&#125;, <span class="number">1</span>&#125;,</span><br><span class="line">    <span class="comment">/* VRH Set, Vap=4.4+... */</span></span><br><span class="line">    &#123;<span class="number">0xC3</span>, &#123;<span class="number">0x15</span>&#125;, <span class="number">1</span>&#125;,</span><br><span class="line">    <span class="comment">/* VDV Set, VDV=0 */</span></span><br><span class="line">    &#123;<span class="number">0xC4</span>, &#123;<span class="number">0x20</span>&#125;, <span class="number">1</span>&#125;,</span><br><span class="line">    <span class="comment">/* Frame Rate Control, 60Hz, inversion=0 */</span></span><br><span class="line">    &#123;<span class="number">0xC6</span>, &#123;<span class="number">0x0f</span>&#125;, <span class="number">1</span>&#125;,</span><br><span class="line">    <span class="comment">/* Power Control 1, AVDD=6.8V, AVCL=-4.8V, VDDS=2.3V */</span></span><br><span class="line">    &#123;<span class="number">0xD0</span>, &#123;<span class="number">0xA4</span>, <span class="number">0xA1</span>&#125;, <span class="number">1</span>&#125;,</span><br><span class="line">    <span class="comment">/* Positive Voltage Gamma Control */</span></span><br><span class="line">    &#123;<span class="number">0xE0</span>, &#123;<span class="number">0xD0</span>,<span class="number">0x08</span>,<span class="number">0x0E</span>,<span class="number">0x09</span>,<span class="number">0x09</span>,<span class="number">0x05</span>,<span class="number">0x31</span>,<span class="number">0x33</span>,<span class="number">0x48</span>,<span class="number">0x17</span>,<span class="number">0x14</span>,<span class="number">0x15</span>,<span class="number">0x31</span>,<span class="number">0x34</span>&#125;, <span class="number">14</span>&#125;,</span><br><span class="line">    <span class="comment">/* Negative Voltage Gamma Control */</span></span><br><span class="line">    &#123;<span class="number">0xE1</span>, &#123;<span class="number">0xD0</span>,<span class="number">0x08</span>,<span class="number">0x0E</span>,<span class="number">0x09</span>,<span class="number">0x09</span>,<span class="number">0x15</span>,<span class="number">0x31</span>,<span class="number">0x33</span>,<span class="number">0x48</span>,<span class="number">0x17</span>,<span class="number">0x14</span>,<span class="number">0x15</span>,<span class="number">0x31</span>,<span class="number">0x34</span>&#125;, <span class="number">14</span>&#125;,</span><br><span class="line">    <span class="comment">/* Sleep Out */</span></span><br><span class="line">    &#123;<span class="number">0x11</span>, &#123;<span class="number">0</span>&#125;, <span class="number">0x80</span>&#125;,</span><br><span class="line">    <span class="comment">/* Display On */</span></span><br><span class="line">    &#123;<span class="number">0x29</span>, &#123;<span class="number">0</span>&#125;, <span class="number">0x80</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>, &#123;<span class="number">0</span>&#125;, <span class="number">0xff</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="/posts/undefined/d8edf0ef5488462f90c314696719f4d9.jpg" class="" title="在这里插入图片描述"><hr><h1 id="相关链接（侵删）"><a href="#相关链接（侵删）" class="headerlink" title="相关链接（侵删）"></a>相关链接（侵删）</h1><ol><li><a href="https://blog.csdn.net/weixin_51803729/article/details/136747907">在esp32上使用tftLCD屏幕（st7789驱动）</a></li><li><a href="https://blog.csdn.net/suyexuan/article/details/120962445">基于 ESP32 的 LCD 模块（ST7789）开发</a></li></ol><hr><center><font color=red>=================我是分割线=================</font></center><p><strong>欢迎到公众号来唠嗑:</strong></p><img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">]]></content>
    
    
    <summary type="html">ESP32使用SPI总线驱动LCD液晶屏</summary>
    
    
    
    <category term="Linux" scheme="https://zml3589110.github.io/categories/Linux/"/>
    
    <category term="乐鑫" scheme="https://zml3589110.github.io/categories/%E4%B9%90%E9%91%AB/"/>
    
    <category term="ESP32" scheme="https://zml3589110.github.io/categories/ESP32/"/>
    
    <category term="ST7789" scheme="https://zml3589110.github.io/categories/ST7789/"/>
    
    
    <category term="Ubuntu" scheme="https://zml3589110.github.io/tags/Ubuntu/"/>
    
    <category term="LCD" scheme="https://zml3589110.github.io/tags/LCD/"/>
    
    <category term="ST7789" scheme="https://zml3589110.github.io/tags/ST7789/"/>
    
    <category term="ESP32" scheme="https://zml3589110.github.io/tags/ESP32/"/>
    
    <category term="乐鑫" scheme="https://zml3589110.github.io/tags/%E4%B9%90%E9%91%AB/"/>
    
    <category term="SDK-IDF" scheme="https://zml3589110.github.io/tags/SDK-IDF/"/>
    
    <category term="液晶屏" scheme="https://zml3589110.github.io/tags/%E6%B6%B2%E6%99%B6%E5%B1%8F/"/>
    
  </entry>
  
  <entry>
    <title>ESP-IDF之头文件问题 - ESP-IDF - 乐鑫 - ESP8266 - 物联网 - ESP32 - Components - 头文件找不到 - CmakeLists</title>
    <link href="https://zml3589110.github.io/posts/1109857756.html"/>
    <id>https://zml3589110.github.io/posts/1109857756.html</id>
    <published>2024-07-18T01:22:20.000Z</published>
    <updated>2024-07-18T01:32:29.256Z</updated>
    
    <content type="html"><![CDATA[<h1 id="找不到头文件"><a href="#找不到头文件" class="headerlink" title="找不到头文件"></a>找不到头文件</h1><p>主要分为两种：一种是在 Components 内找不到，另一种是在自己文件夹内找不到</p><h2 id="情况一（在components文件下添加）"><a href="#情况一（在components文件下添加）" class="headerlink" title="情况一（在components文件下添加）"></a>情况一（在components文件下添加）</h2><img src="/posts/undefined/20210409203320910.png" class="" title="img"><p><strong>就只在官方的DEMO文件里添加了另外一层文件，就出现这个问题。只多了一层“drv”文件夹，如果不要drv文件夹，把uart移动到components下后编译也是正常的。所以出问题肯定是因为makefile出了问题，无法链接编译到需要的文件夹。</strong></p><img src="/posts/undefined/20210409203839719.png" class="" title="img"><p><strong>这里使用两种方法进行解决：</strong></p><h3 id="第一种：修改工程最外层的makefile和cmakelists-txt连个文件。"><a href="#第一种：修改工程最外层的makefile和cmakelists-txt连个文件。" class="headerlink" title="第一种：修改工程最外层的makefile和cmakelists.txt连个文件。"></a>第一种：修改工程最外层的makefile和cmakelists.txt连个文件。</h3><p>添加如下代码</p><img src="/posts/undefined/20210409203736579.png" class="" title="img"><img src="/posts/undefined/20210409203753812.png" class="" title="img"><p>这几句的意思就是让编译器在编译的时候去这几个文件夹下查找需要的文件。<br>在project.cmake文件里有对目录的解释</p><img src="/posts/undefined/20210409204140984.png" class="" title="img"><p>大概意思就是让编译器在这个目录下进行查找。（具体语句我也不是很清楚，惭愧）<br>添加之后编译就可以通过了。</p><h3 id="第二种："><a href="#第二种：" class="headerlink" title="第二种："></a>第二种：</h3><p>编译器之所以链接不到，是因为编译器只能检测到components文件夹的第一层子目录下，就是drv文件夹，该文件夹的子目录不会去链接，因为没有cmakelists.txt文件。<br>所以第二种方式就是在drv文件夹下创建cmakelists.txt文件.</p><img src="/posts/undefined/20210409204706701.png" class="" title="img"><p>在该文件夹下添加包含的文件：</p><img src="/posts/undefined/20210409204749394.png" class="" title="img"><p>这样编译器就能在这里找到drv_uart.c文件了。</p><p>PS:如果采用第一种方法，drv下的cmakelists.txt必须删除掉，否则会报错。语句注释掉也不行。<br>个人建议还是用第一种方法，更正规一点。但是说到底都是编译器没有链接到文件，还是自己学艺不精。<br>这里要感谢一下同事大佬，感谢文哥。</p><p>对了。这个问题并不是很多人说的什么路径问题，我的c_cpp_properties.json文件没有改动。</p><img src="/posts/undefined/20210409205203282.png" class="" title="img"><h2 id="情况二（在非components文件夹下添加）"><a href="#情况二（在非components文件夹下添加）" class="headerlink" title="情况二（在非components文件夹下添加）"></a>情况二（在非components文件夹下添加）</h2><p><strong>比如我们在IDF提供的，hello_world文件夹下添加一个drv文件。这里我们把hello_world文件夹拷贝为test_project工程。在main的同级目录下创建一个drv目录，在该目录下添加文件。此时编译，发现找不到我们的需要的文件。</strong></p><img src="/posts/undefined/aaba9ef371c1442f9a9783699bb66a75.png" class="" title="img"><p> 此时，在main文件夹下的<strong>component.mk</strong>文件中，添加如下代码：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">COMPONENT_ADD_INCLUDEDIRS := . ../drv</span><br><span class="line">COMPONENT_SRCDIRS  := . ../drv</span><br></pre></td></tr></table></figure><p>这样就能让编译连链接到drv目录下。此时再make 。不会报错。</p><hr><h1 id="相关链接（侵删）"><a href="#相关链接（侵删）" class="headerlink" title="相关链接（侵删）"></a>相关链接（侵删）</h1><ol><li><a href="https://blog.csdn.net/qq_26226375/article/details/115558969">ESP32-IDF 使用VSCODE添加自己的头文件后无法找到的问题</a></li></ol><hr><center><font color=red>=================我是分割线=================</font></center><p><strong>欢迎到公众号来唠嗑:</strong></p><img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">]]></content>
    
    
    <summary type="html">ESP-IDF下 头文件相关内容</summary>
    
    
    
    <category term="Linux" scheme="https://zml3589110.github.io/categories/Linux/"/>
    
    <category term="乐鑫" scheme="https://zml3589110.github.io/categories/%E4%B9%90%E9%91%AB/"/>
    
    <category term="ESP-IDF" scheme="https://zml3589110.github.io/categories/ESP-IDF/"/>
    
    <category term="Components" scheme="https://zml3589110.github.io/categories/Components/"/>
    
    <category term="CmakeLists" scheme="https://zml3589110.github.io/categories/CmakeLists/"/>
    
    
  </entry>
  
  <entry>
    <title>ESP32环境搭建和LGVL驱动</title>
    <link href="https://zml3589110.github.io/posts/2149552820.html"/>
    <id>https://zml3589110.github.io/posts/2149552820.html</id>
    <published>2024-07-17T12:04:20.000Z</published>
    <updated>2024-07-18T02:48:07.884Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ESP-IDF-环境搭建"><a href="#ESP-IDF-环境搭建" class="headerlink" title="ESP-IDF 环境搭建"></a>ESP-IDF 环境搭建</h1><p><strong>目前提供的是两个IDF环境，也都能实现编译，这次主要是想重新弄TLT液晶屏下的LVGL，所以从头再弄一次！期间也有挺多问题需要解决，不过Ubuntu环境做的次数相对多一些，所以弄起来顺手点，不过最后发现VSCODE环境更加无脑安装更加方便，就是编译的速度慢了好多，最终还是选择使用Ubuntu</strong></p><h2 id="Ubuntu环境搭建"><a href="#Ubuntu环境搭建" class="headerlink" title="Ubuntu环境搭建"></a>Ubuntu环境搭建</h2><p>这个参考 <a href="https://zml3589110.github.io/posts/2870405859.html">ESP32开发SDK-IDF环境搭建(Ubuntu)</a> 即可<br>基本上能安装并运行demo</p><h2 id="Windows-环境下通过-VSCODE-搭建"><a href="#Windows-环境下通过-VSCODE-搭建" class="headerlink" title="Windows 环境下通过 VSCODE 搭建"></a>Windows 环境下通过 VSCODE 搭建</h2><p>之前没有尝试过，这次感觉使用Ubuntu麻烦，就想着直接使用一个Windows环境看看，这样查代码什么的也方便!</p><h1 id="使用SPI总线驱动LCD（st7789驱动）"><a href="#使用SPI总线驱动LCD（st7789驱动）" class="headerlink" title="使用SPI总线驱动LCD（st7789驱动）"></a>使用SPI总线驱动LCD（st7789驱动）</h1><p>参考文章 <strong>ESP32使用SPI总线驱动LCD</strong></p><h1 id="移植LVGL"><a href="#移植LVGL" class="headerlink" title="移植LVGL"></a>移植LVGL</h1><p><strong>手上的TFT液晶屏是 ST7789 的屏幕，但是默认demo是 ILI9341 这款，虽然跑的时钟 demo 没问题，但是使用 GUI-Guider 生成的UI导入后颜色不对，仔细看才发现使用颜色深度不同，demo驱动使用的8bit，而GUI-Guider只有16或者32，所以就不合适，最后找到了lvgl_esp32_drivers 组件并且修改后才能适配使用，很多地方报错，就拿文件中找不到 drive 目录下gpio.h报错问题来说，其实就是因为 ESP-IDF 从4升级到5后需要在cmake中声明才能使用，不能隐式使用，也算是一种改变，所以还是需要多看官方文档才行！<a href="https://docs.espressif.com/projects/esp-idf/zh_CN/latest/esp32/migration-guides/release-5.x/5.0/build-system.html">迁移构建系统至 ESP-IDF v5.0</a></strong></p><h2 id="ESP32S3移植GUI-Guider下的LVGL（v8-3）"><a href="#ESP32S3移植GUI-Guider下的LVGL（v8-3）" class="headerlink" title="ESP32S3移植GUI-Guider下的LVGL（v8.3）"></a>ESP32S3移植GUI-Guider下的LVGL（v8.3）</h2><p><strong>GUI-Guider安装网上很多，之前自己也记录过文章 <a href="https://zml3589110.github.io/posts/278272964.html">LVGL模拟器NXP GUI Guider使用</a></strong></p><h3 id="一、新建工程"><a href="#一、新建工程" class="headerlink" title="一、新建工程"></a>一、新建工程</h3><p><strong>复制 ESP-IDF 下example&#x2F;get-started&#x2F;sample_project 示例作为基础工程模板,将其拷贝到work目录下并改名为lvgl_base</strong></p><img src="/posts/2149552820/bdc1cbd768b3491dbabe1e60ad79524c.png" class="" title="img"><h3 id="二、移植LVGL"><a href="#二、移植LVGL" class="headerlink" title="二、移植LVGL"></a>二、移植LVGL</h3><ol><li>引入LVGL库</li></ol><p>1.1 创建组件文件夹</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir components</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> components</span><br></pre></td></tr></table></figure><p>1.2. 引入LVGL相关库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//这里引入的是release/v8.3版本的库，也可以选择其它版本</span><br><span class="line">git submodule add -b release/v8.3 https://github.com/lvgl/lvgl.git lvgl</span><br><span class="line">//引入esp32工程库，这个库实现了对lcd显示设备的注册，当然也可以使用自己的方式实现</span><br><span class="line">git submodule add https://github.com/lvgl/lvgl_esp32_drivers.git lvgl_esp32_drivers</span><br></pre></td></tr></table></figure><p><strong>如果在引入库时报下面的问题，则只需要在工程中初始化git 仓库即可</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> lvgl_base</span><br><span class="line"></span><br><span class="line">git init</span><br></pre></td></tr></table></figure><img src="/posts/2149552820/ce7a68e45c464da8b831f145e8b4da1c.png" class="" title="img"><p>1.3. 查看工程结构</p><img src="/posts/2149552820/8b6c66b52fd043a38bfa44dbd382170a.png" class="" title="img"><ol start="2"><li>编译工程</li></ol><p>2.1 配置LCD</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">idf.py set-target esp32s3</span><br><span class="line"></span><br><span class="line">idf.py menuconfig</span><br></pre></td></tr></table></figure><img src="/posts/2149552820/image-20240717203757542.png" class="" title="image-20240717203757542"><img src="/posts/2149552820/image-20240717203825186.png" class="" title="image-20240717203825186"><p><strong>1)设置控制器类型为ST7789</strong><br><strong>2)根据屏幕特性选择反色（一些屏幕不需要）</strong><br><strong>2）配置LCD引脚</strong><br><strong>3）配置背光引脚及电平</strong></p><p>2.2 配置LVGL</p><img src="/posts/2149552820/28f2b8f889de45cea4851877682a60d2.png" class="" title="img"><img src="/posts/2149552820/4bb29d58da4646a48d9342854f2e874a.png" class="" title="img"><p><strong>1）根据屏幕特性选择交换颜色字节（一些屏幕不需要）</strong><br><strong>2）使能一些demo用到的字体</strong><br><strong>3）使能music demo</strong></p><ol start="3"><li>主函数代码</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;esp_log.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;esp_system.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;freertos/FreeRTOS.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;freertos/event_groups.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;lvgl.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;lvgl_helpers.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;demos/lv_demos.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TAG <span class="meta-string">&quot;main&quot;</span></span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lv_tick_task</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    lv_tick_inc(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">app_main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Initialize SPI or I2C bus used by the drivers */</span></span><br><span class="line">    lvgl_driver_init();</span><br><span class="line"> </span><br><span class="line">    lv_init();</span><br><span class="line">    <span class="keyword">lv_color_t</span> *buf1 = heap_caps_malloc(DISP_BUF_SIZE * <span class="keyword">sizeof</span>(<span class="keyword">lv_color_t</span>), MALLOC_CAP_DMA);</span><br><span class="line">    assert(buf1 != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">lv_color_t</span> *buf2 = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">lv_disp_draw_buf_t</span> disp_buf;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">uint32_t</span> size_in_px = DISP_BUF_SIZE;</span><br><span class="line">    lv_disp_draw_buf_init(&amp;disp_buf, buf1, buf2, size_in_px);</span><br><span class="line">    <span class="keyword">lv_disp_drv_t</span> disp_drv;</span><br><span class="line">    lv_disp_drv_init(&amp;disp_drv);</span><br><span class="line">    disp_drv.hor_res = LV_HOR_RES_MAX;</span><br><span class="line">    disp_drv.ver_res = LV_VER_RES_MAX;</span><br><span class="line">    disp_drv.flush_cb = disp_driver_flush;</span><br><span class="line">    disp_drv.draw_buf = &amp;disp_buf;</span><br><span class="line">    lv_disp_drv_register(&amp;disp_drv);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">esp_timer_create_args_t</span> periodic_timer_args = &#123;</span><br><span class="line">        .callback = &amp;lv_tick_task,</span><br><span class="line">        .name = <span class="string">&quot;periodic_gui&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">esp_timer_handle_t</span> periodic_timer;</span><br><span class="line">    ESP_ERROR_CHECK(esp_timer_create(&amp;periodic_timer_args, &amp;periodic_timer));</span><br><span class="line">    ESP_ERROR_CHECK(esp_timer_start_periodic(periodic_timer, <span class="number">1</span> * <span class="number">1000</span>));</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// lvgl demo演示</span></span><br><span class="line">    lv_demo_music();</span><br><span class="line">    <span class="comment">// lv_demo_stress();</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Delay 1 tick (assumes FreeRTOS tick is 10ms */</span></span><br><span class="line">        vTaskDelay(pdMS_TO_TICKS(<span class="number">10</span>));</span><br><span class="line">        lv_task_handler();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、报错修改"><a href="#三、报错修改" class="headerlink" title="三、报错修改"></a>三、报错修改</h3><h4 id="1-error-‘LV-HOR-RES-MAX’-undeclared"><a href="#1-error-‘LV-HOR-RES-MAX’-undeclared" class="headerlink" title="1.error: ‘LV_HOR_RES_MAX’ undeclared"></a>1.error: ‘LV_HOR_RES_MAX’ undeclared</h4><img src="/posts/2149552820/fe6e01fba7124967a701e19d682c213c.png" class="" title="img"><p><strong>解决方式：在lvgl_helpers.h 中增加如下代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LV_HOR_RES_MAX 320</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LV_VER_RES_MAX 240</span></span><br><span class="line"><span class="comment">//#define SPI_HOST_MAX 3  在最新的IDF驱动中已经有这个了，加这个会报错误重复</span></span><br></pre></td></tr></table></figure><h4 id="2-E-384-spi-spi-bus-initialize-762-invalid-dma-channel-chip-only-support-spi-dma-channel-auto-alloc"><a href="#2-E-384-spi-spi-bus-initialize-762-invalid-dma-channel-chip-only-support-spi-dma-channel-auto-alloc" class="headerlink" title="2.E (384) spi: spi_bus_initialize(762): invalid dma channel, chip only support spi dma channel auto-alloc"></a>2.E (384) spi: spi_bus_initialize(762): invalid dma channel, chip only support spi dma channel auto-alloc</h4><img src="/posts/2149552820/b5b00eb2286c413ebb727e44ecc43f28.png" class="" title="img"><p><strong>解决方式：在lvgl_helpers.c 中增加如下代码</strong></p><img src="/posts/2149552820/21fddf6323e2486789e3c8e2f0cb9779.png" class="" title="img"><p><strong>在这次实验中并没有报这个错误，所以不需要改 IDF-5.2</strong></p><h4 id="3-找不到-driver-文件下的-gpio-h-和-ledc-h"><a href="#3-找不到-driver-文件下的-gpio-h-和-ledc-h" class="headerlink" title="3. 找不到 driver 文件下的 gpio.h 和 ledc.h"></a>3. 找不到 driver 文件下的 gpio.h 和 ledc.h</h4><p><strong>解决办法：修改使用cmake文件，让组件能找到位置</strong></p><p>根据 <a href="https://docs.espressif.com/projects/esp-idf/zh_CN/latest/esp32/migration-guides/release-5.x/5.0/build-system.html">迁移构建系统至 ESP-IDF v5.0</a> 说明迁移后需要在cmake明确指定组件依赖</p><img src="/posts/2149552820/image-20240717205040333.png" class="" title="image-20240717205040333"><p>idf_component_register 新增加 REQUIRES driver 即可</p><p><a href="https://blog.csdn.net/wf19930225/article/details/129196540">2_light_drivers esp-idf5.x报错 Failed to resolve component ‘esp_adc_cal‘</a></p><h4 id="4-报了-gpio等其他"><a href="#4-报了-gpio等其他" class="headerlink" title="4. 报了 gpio等其他"></a>4. 报了 gpio等其他</h4><p><strong>本次就直接把错误的部分代码屏蔽掉即可</strong></p><img src="/posts/2149552820/image-20240717205240035.png" class="" title="image-20240717205240035"><p>例如 <strong>st7789.c</strong> 文件中的 <strong>gpio_pad_select_gpio(ST7789_DC);</strong> 就报错了，直接屏蔽后使用也正常</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在驱动LCD屏幕方面，lvgl_esp32_drivers 库目前只支持了spi以及I2C的方式，对于8080接口是没有支持的，这时候可以使用esp-who 的screen 组件来实现驱屏。</p><hr><h1 id="相关链接（侵删）"><a href="#相关链接（侵删）" class="headerlink" title="相关链接（侵删）"></a>相关链接（侵删）</h1><ol><li><p><a href="https://blog.csdn.net/m0_55986987/article/details/132875484?spm=1001.2014.3001.5502">ESP32系列之LVGL（二）：ESP32S3移植LVGL（v8.3）</a></p></li><li><p><a href="https://github.com/lvgl/lv_port_esp32">LVGL库</a></p></li><li><p><a href="https://github.com/espressif/esp-who">ESP-WHO库</a></p></li><li><p><a href="https://blog.csdn.net/chentuo2000/article/details/128269394">ESP32 ESP-IDF LVGL8.3.3移植</a></p></li><li><p><a href="https://docs.espressif.com/projects/esp-idf/zh_CN/latest/esp32/migration-guides/release-5.x/5.0/build-system.html">迁移构建系统至 ESP-IDF v5.0</a></p></li><li><p><a href="https://blog.csdn.net/weixin_51803729/article/details/136747907">在esp32上使用tftLCD屏幕（st7789驱动）</a></p></li></ol><hr><center><font color=red>=================我是分割线=================</font></center><p><strong>欢迎到公众号来唠嗑:</strong></p><img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">]]></content>
    
    
    <summary type="html">搭建ESP32开发环境，并实现LVGL液晶屏显示</summary>
    
    
    
    <category term="Linux" scheme="https://zml3589110.github.io/categories/Linux/"/>
    
    <category term="文件共享" scheme="https://zml3589110.github.io/categories/%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB/"/>
    
    <category term="乐鑫" scheme="https://zml3589110.github.io/categories/%E4%B9%90%E9%91%AB/"/>
    
    <category term="ESP32" scheme="https://zml3589110.github.io/categories/ESP32/"/>
    
    <category term="LVGL" scheme="https://zml3589110.github.io/categories/LVGL/"/>
    
    <category term="GUI-Guider" scheme="https://zml3589110.github.io/categories/GUI-Guider/"/>
    
    
    <category term="Ubuntu" scheme="https://zml3589110.github.io/tags/Ubuntu/"/>
    
    <category term="物联网" scheme="https://zml3589110.github.io/tags/%E7%89%A9%E8%81%94%E7%BD%91/"/>
    
    <category term="LVGL" scheme="https://zml3589110.github.io/tags/LVGL/"/>
    
    <category term="ESP32" scheme="https://zml3589110.github.io/tags/ESP32/"/>
    
    <category term="乐鑫" scheme="https://zml3589110.github.io/tags/%E4%B9%90%E9%91%AB/"/>
    
    <category term="SDK-IDF" scheme="https://zml3589110.github.io/tags/SDK-IDF/"/>
    
    <category term="开发环境" scheme="https://zml3589110.github.io/tags/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    
    <category term="安装问题" scheme="https://zml3589110.github.io/tags/%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98/"/>
    
    <category term="Windows" scheme="https://zml3589110.github.io/tags/Windows/"/>
    
    <category term="VSCODE" scheme="https://zml3589110.github.io/tags/VSCODE/"/>
    
    <category term="GUI-Guider" scheme="https://zml3589110.github.io/tags/GUI-Guider/"/>
    
  </entry>
  
  <entry>
    <title>卸载PHP</title>
    <link href="https://zml3589110.github.io/posts/2401450114.html"/>
    <id>https://zml3589110.github.io/posts/2401450114.html</id>
    <published>2024-05-31T09:22:20.000Z</published>
    <updated>2024-07-17T13:26:21.021Z</updated>
    
    <content type="html"><![CDATA[<h1 id="卸载现有php"><a href="#卸载现有php" class="headerlink" title="卸载现有php"></a>卸载现有php</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apt-get autoremove php7*</span><br><span class="line">find /etc -name <span class="string">&quot;*php*&quot;</span> |xargs  rm -rf</span><br><span class="line">apt purge `dpkg -l | grep php| awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span> |tr <span class="string">&quot;\n&quot;</span> <span class="string">&quot; &quot;</span>`</span><br></pre></td></tr></table></figure><p><strong>编译安装php</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apt install gcc make libxml2 libxml2-dev</span><br><span class="line">wget http://cn2.php.net/distributions/php-7.3.3.tar.bz2</span><br><span class="line">tar -xjf php-7.3.3.tar.bz2</span><br><span class="line">./configure &amp;&amp; make &amp;&amp; make install</span><br></pre></td></tr></table></figure><h1 id="查看PHP信息"><a href="#查看PHP信息" class="headerlink" title="查看PHP信息"></a>查看PHP信息</h1><p>在.php文件中输入phpinfo();查看mysqli是否成功连接，显示有mysqli就表示成功连接上了</p><hr><h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><ol><li><a href="https://www.cnblogs.com/wdxgg/p/11988884.html">debian 卸载&#x2F;安装php 安装swoole扩展</a></li></ol><hr><center><font color=red>=================我是分割线=================</font></center><p><strong>欢迎到公众号来唠嗑:</strong></p><img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">]]></content>
    
    
    <summary type="html">在Debian arm系统上完全卸载PHP</summary>
    
    
    
    <category term="编程类" scheme="https://zml3589110.github.io/categories/%E7%BC%96%E7%A8%8B%E7%B1%BB/"/>
    
    <category term="VUE" scheme="https://zml3589110.github.io/categories/%E7%BC%96%E7%A8%8B%E7%B1%BB/VUE/"/>
    
    <category term="前端" scheme="https://zml3589110.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="PHP" scheme="https://zml3589110.github.io/categories/PHP/"/>
    
    
    <category term="linux" scheme="https://zml3589110.github.io/tags/linux/"/>
    
    <category term="Debain" scheme="https://zml3589110.github.io/tags/Debain/"/>
    
    <category term="PHP" scheme="https://zml3589110.github.io/tags/PHP/"/>
    
    <category term="卸载" scheme="https://zml3589110.github.io/tags/%E5%8D%B8%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>4Nginx安装并部署vue（Debain系统）</title>
    <link href="https://zml3589110.github.io/posts/975746674.html"/>
    <id>https://zml3589110.github.io/posts/975746674.html</id>
    <published>2024-05-30T13:11:20.000Z</published>
    <updated>2024-05-30T13:23:01.045Z</updated>
    
    <content type="html"><![CDATA[<p>收集的文章：</p><p>按照这个：<br><a href="https://blog.csdn.net/One__buyaomanggu/article/details/136619437">vue项目部署到linx服务器（debian）</a></p><p><a href="https://cloud.tencent.com/developer/article/1834769">一篇文章、三种方法在Debian上轻松安装Nginx</a></p><p><a href="https://www.cnblogs.com/sunxun001/p/14031376.html">Linux安装nginx及部署vue项目</a></p><p><a href="https://www.jb51.net/article/262472.htm">nginx部署vue项目的详细图文教程</a></p><hr><h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><hr><center><font color=red>=================我是分割线=================</font></center><p><strong>欢迎到公众号来唠嗑:</strong></p><img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">]]></content>
    
    
    <summary type="html">在Debian arm系统上完成nginx服务安装并将VUE放入其中</summary>
    
    
    
    <category term="编程类" scheme="https://zml3589110.github.io/categories/%E7%BC%96%E7%A8%8B%E7%B1%BB/"/>
    
    <category term="VUE" scheme="https://zml3589110.github.io/categories/%E7%BC%96%E7%A8%8B%E7%B1%BB/VUE/"/>
    
    <category term="前端" scheme="https://zml3589110.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="Nginx" scheme="https://zml3589110.github.io/categories/Nginx/"/>
    
    
    <category term="linux" scheme="https://zml3589110.github.io/tags/linux/"/>
    
    <category term="Debain" scheme="https://zml3589110.github.io/tags/Debain/"/>
    
    <category term="网页" scheme="https://zml3589110.github.io/tags/%E7%BD%91%E9%A1%B5/"/>
    
    <category term="JavaScript" scheme="https://zml3589110.github.io/tags/JavaScript/"/>
    
    <category term="VUE" scheme="https://zml3589110.github.io/tags/VUE/"/>
    
    <category term="Nginx" scheme="https://zml3589110.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>c#硬件温度获取</title>
    <link href="https://zml3589110.github.io/posts/3247989740.html"/>
    <id>https://zml3589110.github.io/posts/3247989740.html</id>
    <published>2024-04-15T13:00:20.000Z</published>
    <updated>2024-04-15T13:23:39.318Z</updated>
    
    <content type="html"><![CDATA[<h1 id="作用缘由"><a href="#作用缘由" class="headerlink" title="作用缘由"></a>作用缘由</h1><p>想通过命令来获取到当前硬件状态后通过MQTT发送到相应服务器。相应的也能学习到C#获取方法，刚开始查询到的是使用 OpenHardwareMonitor 获取状态，其实这个软件也一直在使用，而且也能通过tcp端口查询到win环境下的硬件状态。不过，尝试之后发现当前net6.0版本并不适合，或者说这个如今已经不维护了，这也是在一片评论中看到，并且也提到了 LibreHardwareMonitor 这个库。不过之前的也是有参考价值。</p><h1 id="OpenHardwareMonitor-方法跟步骤"><a href="#OpenHardwareMonitor-方法跟步骤" class="headerlink" title="OpenHardwareMonitor 方法跟步骤"></a>OpenHardwareMonitor 方法跟步骤</h1><p>C# 去获取电脑相关的基础信息，还是需要借助 外部的库，我这边尝试了自己去实现它</p><p>网上有一些信息，但不太完整，都比较零碎，这边尽量将代码完整的去展示出来</p><p>OpenHardwareMonitor获取CPU的温度和频率需要管理员权限<br>在没有开权限的时候就是无法使用</p><h2 id="首先添加相关应用的dll文件"><a href="#首先添加相关应用的dll文件" class="headerlink" title="首先添加相关应用的dll文件"></a>首先添加相关应用的dll文件</h2><p><strong>引用–&gt;添加引用—&gt;浏览（选择文件）–&gt;确定</strong></p><img src="/posts/3247989740/8b65374aa73d4ea2ade6e8ddbb93d7be.png" class="" title="在这里插入图片描述"><h2 id="添加头文件"><a href="#添加头文件" class="headerlink" title="添加头文件"></a>添加头文件</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> OpenHardwareMonitor.Hardware;</span><br><span class="line"><span class="keyword">using</span> System.Threading;</span><br></pre></td></tr></table></figure><h2 id="添加相关代码，我这边就将整个form的代码贴上来了，这样也方便查看"><a href="#添加相关代码，我这边就将整个form的代码贴上来了，这样也方便查看" class="headerlink" title="添加相关代码，我这边就将整个form的代码贴上来了，这样也方便查看"></a>添加相关代码，我这边就将整个form的代码贴上来了，这样也方便查看</h2><p>代码中注释掉的部分是循环显示的一个循环逻辑</p><p>代码的功能可以将主板的名称显示出来，还有将第一个CPU的情况显示，可以根据实际情况进行修改。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.ComponentModel;</span><br><span class="line"><span class="keyword">using</span> System.Data;</span><br><span class="line"><span class="keyword">using</span> System.Drawing;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"><span class="keyword">using</span> System.Diagnostics;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> OpenHardwareMonitor.Hardware;</span><br><span class="line"><span class="keyword">using</span> System.Threading;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">cpuGpu</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Form1</span> : <span class="title">Form</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UpdateVisitor</span> : <span class="title">IVisitor</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">VisitComputer</span>(<span class="params">IComputer computer</span>)</span></span><br><span class="line"><span class="function"></span>            &#123;</span><br><span class="line">                computer.Traverse(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">VisitHardware</span>(<span class="params">IHardware hardware</span>)</span></span><br><span class="line"><span class="function"></span>            &#123;</span><br><span class="line">                hardware.Update();</span><br><span class="line">                <span class="keyword">foreach</span> (IHardware subHardware <span class="keyword">in</span> hardware.SubHardware)</span><br><span class="line">                    subHardware.Accept(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">VisitSensor</span>(<span class="params">ISensor sensor</span>)</span> &#123; &#125;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">VisitParameter</span>(<span class="params">IParameter parameter</span>)</span> &#123; &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Form1</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            InitializeComponent();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">button2_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            UpdateVisitor updateVisitor = <span class="keyword">new</span> UpdateVisitor();</span><br><span class="line">            Computer myComputer = <span class="keyword">new</span> Computer();</span><br><span class="line">            myComputer.Open();</span><br><span class="line">            <span class="comment">//启动主板监测</span></span><br><span class="line">            myComputer.MainboardEnabled = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//启动CPU监测</span></span><br><span class="line">            myComputer.CPUEnabled = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//启动内存监测</span></span><br><span class="line">            myComputer.RAMEnabled = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//启动GPU监测</span></span><br><span class="line">            myComputer.GPUEnabled = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//启动风扇监测</span></span><br><span class="line">            myComputer.FanControllerEnabled = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//启动硬盘监测</span></span><br><span class="line">            myComputer.HDDEnabled = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">            &#123;</span><br><span class="line">                myComputer.Accept(updateVisitor);</span><br><span class="line">                Console.Clear();</span><br><span class="line">                <span class="comment">//foreach (var hardwareItem in myComputer.Hardware)</span></span><br><span class="line">                <span class="comment">//&#123;</span></span><br><span class="line">                <span class="comment">//    Console.WriteLine(hardwareItem.HardwareType + &quot;型号是：&quot; + hardwareItem.Name);</span></span><br><span class="line">                <span class="comment">//    foreach (var sensor in hardwareItem.Sensors)</span></span><br><span class="line">                <span class="comment">//    &#123;</span></span><br><span class="line">                <span class="comment">//        Console.WriteLine(sensor.Name + &quot;的&quot; + sensor.SensorType + &quot;是&quot; + sensor.Value);</span></span><br><span class="line">                <span class="comment">//    &#125;</span></span><br><span class="line">                <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">                <span class="built_in">string</span> BroadName = myComputer.Hardware[<span class="number">0</span>].Name.ToString();</span><br><span class="line">                <span class="built_in">string</span> CPUdata = myComputer.Hardware[<span class="number">1</span>].Sensors[<span class="number">0</span>].Value.ToString();</span><br><span class="line"></span><br><span class="line">                System.Threading.Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="上述OpenHardwareMonitor方法被弃用了"><a href="#上述OpenHardwareMonitor方法被弃用了" class="headerlink" title="上述OpenHardwareMonitor方法被弃用了"></a>上述OpenHardwareMonitor方法被弃用了</h2><img src="/posts/3247989740/image-20240415211403556.png" class="" title="image-20240415211403556"><h1 id="LibreHardwareMonitorLib-方法完成"><a href="#LibreHardwareMonitorLib-方法完成" class="headerlink" title="LibreHardwareMonitorLib 方法完成"></a>LibreHardwareMonitorLib 方法完成</h1><p><strong>库添加方法跟前面一样</strong></p><p>win10温度获取的方法，在win11已经不行了<br>下面是win11获取温度代码 先安装包 LibreHardwareMonitorLib 用管理员身份运行</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> LibreHardwareMonitor.Hardware;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line">namespace 硬件温度2</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UpdateVisitor</span> : <span class="title">IVisitor</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">VisitComputer</span>(<span class="params">IComputer computer</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            computer.Traverse(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">VisitHardware</span>(<span class="params">IHardware hardware</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            hardware.Update();</span><br><span class="line">            <span class="keyword">foreach</span> (IHardware subHardware <span class="keyword">in</span> hardware.SubHardware) subHardware.Accept(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">VisitSensor</span>(<span class="params">ISensor sensor</span>)</span> &#123; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">VisitParameter</span>(<span class="params">IParameter parameter</span>)</span> &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Monitor</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Computer computer = <span class="keyword">new</span> Computer</span><br><span class="line">            &#123;</span><br><span class="line">                IsCpuEnabled = <span class="literal">true</span>,</span><br><span class="line">                IsGpuEnabled = <span class="literal">true</span>,</span><br><span class="line">                IsMemoryEnabled = <span class="literal">true</span>,</span><br><span class="line">                IsMotherboardEnabled = <span class="literal">true</span>,</span><br><span class="line">                IsControllerEnabled = <span class="literal">true</span>,</span><br><span class="line">                IsNetworkEnabled = <span class="literal">true</span>,</span><br><span class="line">                IsStorageEnabled = <span class="literal">true</span></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            computer.Open();</span><br><span class="line">            computer.Accept(<span class="keyword">new</span> UpdateVisitor());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">foreach</span> (IHardware hardware <span class="keyword">in</span> computer.Hardware)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Hardware: &#123;0&#125;&quot;</span>, hardware.Name);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">foreach</span> (IHardware subhardware <span class="keyword">in</span> hardware.SubHardware)</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;\tSubhardware: &#123;0&#125;&quot;</span>, subhardware.Name);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">foreach</span> (ISensor sensor <span class="keyword">in</span> subhardware.Sensors)</span><br><span class="line">                    &#123;</span><br><span class="line">                        Console.WriteLine(<span class="string">&quot;\t\tSensor: &#123;0&#125;, value: &#123;1&#125;&quot;</span>, sensor.Name, sensor.Value);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">foreach</span> (ISensor sensor <span class="keyword">in</span> hardware.Sensors)</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;\tSensor: &#123;0&#125;, value: &#123;1&#125;&quot;</span>, sensor.Name, sensor.Value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            computer.Close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Monitor();</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="自己调整的方法"><a href="#自己调整的方法" class="headerlink" title="自己调整的方法"></a>自己调整的方法</h1><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HardwareMonitor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UpdateVisitor</span> : <span class="title">IVisitor</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">VisitComputer</span>(<span class="params">IComputer computer</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            computer.Traverse(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">VisitHardware</span>(<span class="params">IHardware hardware</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            hardware.Update();</span><br><span class="line">            <span class="keyword">foreach</span> (IHardware subHardware <span class="keyword">in</span> hardware.SubHardware)</span><br><span class="line">                subHardware.Accept(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">VisitSensor</span>(<span class="params">ISensor sensor</span>)</span> &#123; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">VisitParameter</span>(<span class="params">IParameter parameter</span>)</span> &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HardwareMonitorRead</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//UpdateVisitor updateVisitor = new();</span></span><br><span class="line">        <span class="comment">//Computer myComputer = new();</span></span><br><span class="line">        <span class="comment">//myComputer.Open();</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span>/启动主板监测</span></span><br><span class="line">        <span class="comment">//myComputer.MainboardEnabled = true;</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span>/启动CPU监测</span></span><br><span class="line">        <span class="comment">//myComputer.CPUEnabled = true;</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span>/启动内存监测</span></span><br><span class="line">        <span class="comment">//myComputer.RAMEnabled = true;</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span>/启动GPU监测</span></span><br><span class="line">        <span class="comment">//myComputer.GPUEnabled = true;</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span>/启动风扇监测</span></span><br><span class="line">        <span class="comment">//myComputer.FanControllerEnabled = true;</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span>/启动硬盘监测</span></span><br><span class="line">        <span class="comment">//myComputer.HDDEnabled = true;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//myComputer.Accept(updateVisitor);</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span>/Console.Clear();</span></span><br><span class="line">        <span class="comment">//foreach (var hardwareItem in myComputer.Hardware)</span></span><br><span class="line">        <span class="comment">//&#123;</span></span><br><span class="line">        <span class="comment">//    Debug.WriteLine(hardwareItem.HardwareType + &quot;型号是：&quot; + hardwareItem.Name);</span></span><br><span class="line">        <span class="comment">//    foreach (var sensor in hardwareItem.Sensors)</span></span><br><span class="line">        <span class="comment">//    &#123;</span></span><br><span class="line">        <span class="comment">//        Debug.WriteLine(sensor.Name + &quot;的&quot; + sensor.SensorType + &quot;是&quot; + sensor.Value);</span></span><br><span class="line">        <span class="comment">//    &#125;</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">        Computer computer = <span class="keyword">new</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            IsCpuEnabled = <span class="literal">true</span>,    <span class="comment">//启动CPU监测</span></span><br><span class="line">            IsGpuEnabled = <span class="literal">true</span>,    <span class="comment">//启动GPU监测</span></span><br><span class="line">            IsMemoryEnabled = <span class="literal">true</span>, <span class="comment">//启动内存监测</span></span><br><span class="line">            IsMotherboardEnabled = <span class="literal">true</span>,    <span class="comment">//启动主板监测</span></span><br><span class="line">            IsControllerEnabled = <span class="literal">true</span>,     <span class="comment">//启动控制器监测</span></span><br><span class="line">            <span class="comment">//IsNetworkEnabled = true,</span></span><br><span class="line">            IsStorageEnabled = <span class="literal">true</span> <span class="comment">//启动硬盘监测</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        computer.Open();</span><br><span class="line">        computer.Accept(<span class="keyword">new</span> UpdateVisitor());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> hardwareItem <span class="keyword">in</span> computer.Hardware)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.WriteLine(hardwareItem.HardwareType + <span class="string">&quot;型号是：&quot;</span> + hardwareItem.Name);</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> sensor <span class="keyword">in</span> hardwareItem.Sensors)</span><br><span class="line">            &#123;</span><br><span class="line">                Debug.WriteLine(sensor.Name + <span class="string">&quot;的&quot;</span> + sensor.SensorType + <span class="string">&quot;是&quot;</span> + sensor.Value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//foreach (IHardware hardware in computer.Hardware)</span></span><br><span class="line">        <span class="comment">//&#123;</span></span><br><span class="line">        <span class="comment">//    Debug.WriteLine(&quot;Hardware: &#123;0&#125;&quot;, hardware.Name);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//    foreach (IHardware subhardware in hardware.SubHardware)</span></span><br><span class="line">        <span class="comment">//    &#123;</span></span><br><span class="line">        <span class="comment">//        Debug.WriteLine(&quot;\tSubhardware: &#123;0&#125;&quot;, subhardware.Name);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//        foreach (ISensor sensor in subhardware.Sensors)</span></span><br><span class="line">        <span class="comment">//        &#123;</span></span><br><span class="line">        <span class="comment">//            Debug.WriteLine(&quot;\t\tSensor: &#123;0&#125;, value: &#123;1&#125;&quot;, sensor.Name, sensor.Value);</span></span><br><span class="line">        <span class="comment">//        &#125;</span></span><br><span class="line">        <span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//    foreach (ISensor sensor in hardware.Sensors)</span></span><br><span class="line">        <span class="comment">//    &#123;</span></span><br><span class="line">        <span class="comment">//        Debug.WriteLine(&quot;\tSensor: &#123;0&#125;, value: &#123;1&#125;&quot;, sensor.Name, sensor.Value);</span></span><br><span class="line">        <span class="comment">//    &#125;</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">        computer.Close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><h1 id="相关链接（侵删）"><a href="#相关链接（侵删）" class="headerlink" title="相关链接（侵删）"></a>相关链接（侵删）</h1><ol><li><a href="https://www.cnblogs.com/txwtech/p/16179740.html">（就是参照的这个）win11 c#硬件温度获取</a></li><li><a href="https://blog.csdn.net/chen1658137632/article/details/135343556">C#使用 OpenHardwareMonitor 获取CPU或显卡温度、使用率、时钟频率相关方式</a></li><li><a href="https://stackoverflow.com/questions/1195112/how-can-i-get-the-cpu-temperature">How can I get the CPU temperature?</a></li><li><a href="https://q.cnblogs.com/q/42203">C#如何获取电脑CPU温度，硬盘温度，主板温度，CPU转速</a></li></ol><hr><center><font color=red>=================我是分割线=================</font></center><p><strong>欢迎到公众号来唠嗑:</strong></p><img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">]]></content>
    
    
    <summary type="html">C# 程序编译时自动更新版本号方法</summary>
    
    
    
    <category term="编程类" scheme="https://zml3589110.github.io/categories/%E7%BC%96%E7%A8%8B%E7%B1%BB/"/>
    
    <category term="C#" scheme="https://zml3589110.github.io/categories/%E7%BC%96%E7%A8%8B%E7%B1%BB/C/"/>
    
    <category term="前端" scheme="https://zml3589110.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="硬件温度" scheme="https://zml3589110.github.io/categories/%E7%A1%AC%E4%BB%B6%E6%B8%A9%E5%BA%A6/"/>
    
    
    <category term="C#" scheme="https://zml3589110.github.io/tags/C/"/>
    
    <category term="硬件温度" scheme="https://zml3589110.github.io/tags/%E7%A1%AC%E4%BB%B6%E6%B8%A9%E5%BA%A6/"/>
    
    <category term="OpenHardwareMonitor" scheme="https://zml3589110.github.io/tags/OpenHardwareMonitor/"/>
    
    <category term="LibreHardwareMonitor" scheme="https://zml3589110.github.io/tags/LibreHardwareMonitor/"/>
    
  </entry>
  
  <entry>
    <title>电磁炉主要元器件</title>
    <link href="https://zml3589110.github.io/posts/203927772.html"/>
    <id>https://zml3589110.github.io/posts/203927772.html</id>
    <published>2024-04-13T08:43:20.000Z</published>
    <updated>2024-04-13T09:08:27.605Z</updated>
    
    <content type="html"><![CDATA[<h1 id="主要元器件"><a href="#主要元器件" class="headerlink" title="主要元器件"></a>主要元器件</h1><p><strong>完整内部图</strong></p><img src="/posts/203927772/image-20240413164824837.png" class="" title="image-20240413164824837"><ol><li>炉盘线圈</li></ol><img src="/posts/203927772/image-20240413164659643.png" class="" title="image-20240413164659643"><ol start="2"><li>热敏电阻</li></ol><img src="/posts/203927772/image-20240413164904574.png" class="" title="image-20240413164904574"><ol start="3"><li>主电路板</li></ol><img src="/posts/203927772/image-20240413165003252.png" class="" title="image-20240413165003252"><ol start="4"><li><p>显示电路板</p><img src="/posts/203927772/image-20240413165033420.png" class="" title="image-20240413165033420"></li><li><p>风扇</p><img src="/posts/203927772/image-20240413165331961.png" class="" title="image-20240413165331961"></li><li><p>散热器</p><img src="/posts/203927772/image-20240413165345163.png" class="" title="image-20240413165345163"></li><li><p>谐振、滤波电容</p><img src="/posts/203927772/image-20240413165357093.png" class="" title="image-20240413165357093"></li><li><p>共模电感</p><img src="/posts/203927772/image-20240413165422942.png" class="" title="image-20240413165422942"></li><li><p>压敏电阻</p><img src="/posts/203927772/image-20240413165432736.png" class="" title="image-20240413165432736"></li><li><p>保险丝</p>  <img src="/posts/203927772/image-20240413165432736.png" class="" title="image-20240413165432736"></li><li><p>电源线和磁环</p></li></ol><img src="/posts/203927772/image-20240413165502914.png" class="" title="image-20240413165502914"><p>电磁炉的整流桥和功率管TGBT并不像组装电脑时主板、CPU、内存、硬盘等必须要相互匹配才能够使用，整流桥和IGBT可以分别独立考虑，没有必须相互匹配这一说，只要它们的耐压、电流、功率等参数完全能够满足电路系统设计要求即可。</p><img src="/posts/203927772/image-20240413165535331.png" class="" title="image-20240413165535331"><img src="/posts/203927772/image-20240413165550622.png" class="" title="image-20240413165550622"><p>1、电磁炉的整流桥</p><p>电磁炉的整流桥应用在220V高压交流电后端，直接将输入的220V交流电整流，得到310V左右的高压直流电，其主要功率回路为滤波电感、磁盘线圈（锅具线盘）、功率管IGBT，可见310V只要功率负载为电磁炉线盘，家用电磁炉的功率一般3000W左右，比如3000W、2200W、2000W等。</p><p>整流桥选型时，需要根据电磁炉的功率进行选取，比如3000W的电磁炉，整流桥的输入电流约15A，再加上70%~80%的降额设计，整流桥的电流应选择20A以上；关于耐压值，220V交流电整流后最高电压约311V，考虑220V交流电输入有可能偏高，再加上降额设计，其耐压值选取必须400V以上，比如常用的电磁炉整流桥D20ⅩB60其参数为20A&#x2F;600V，D20ⅩB80参数为20A&#x2F;800V，GBJ2508参数为25A&#x2F;800V，GBJ2510参数为25A&#x2F;1000V。由于整流桥属于电磁炉易坏元器件，故在元器件选型更换时，最好选择耐压值较高的，比如800V、1000V，可防止较高的雷电及电路反峰冲击；电流选择偏大一些，比如3000W以内的电磁炉整流桥电流可选择25A以上的，降额越大元器件更可靠、更耐用。</p><img src="/posts/203927772/%E7%94%B5%E7%A3%81%E7%82%89%E7%9A%84%E6%95%B4%E6%B5%81%E6%A1%A5.webp" class="" title="电磁炉的整流桥"><p>2、电磁炉的功率管IGBT</p><img src="/posts/203927772/%E7%94%B5%E7%A3%81%E7%82%89%E7%9A%84%E5%8A%9F%E7%8E%87%E7%AE%A1IGBT.webp" class="" title="电磁炉的功率管IGBT"><p>电磁炉的功率管IGBT用于控制电磁炉线盘接通&#x2F;断开，以及通过脉宽调制调节电磁炉的功率。功率管IGBT工作在310V高压直流回路当中，控制线圈加热，电磁炉内部的系统检测电路，比如功率管温度检测、锅底温度检测、过压欠压检测、电流检测最终都是反馈到控制电路当中，控制执行器件IGBT。电磁炉功率档位选择是通过改变PWM脉冲宽度实现的，输出脉冲信号高电平占空比越大，电磁炉的功率越大。</p><img src="/posts/203927772/%E7%94%B5%E7%A3%81%E7%82%89%E7%9A%84%E5%8A%9F%E7%8E%87%E7%AE%A1IGBT1.webp" class="" title="电磁炉的功率管IGBT1"><p>电磁炉功率管IGBT该如何选型呢？选择电磁炉的IGBT最关键的两个技术指标为工作电压和工作电流，这两个参数直接取决于该管子能不能够使用，其它参数比如饱和压降、最大冲击电流、工作温度等只影响电路的性能。</p><p>对于工作电压最好选择1000V以上，虽然正常回路电压只有310V左右，但是由于开关管高速开通&#x2F;断开，会产生高频干扰信号，而且加热线盘属于电感，断开瞬间会产生很高的反电动势；<br>其次是最大集电极电流，需参考电磁炉的最大功率，比如3000W的电磁炉，其工作电流为10A左右，管子最大电流最好按2倍电流以上选取，比如20A、25A等，因为电磁炉的功率经过脉宽调制，其最大电流瞬态远超计算的额定电流。<br>比如常用的电磁炉功率管IGBT：H20R1202&#x2F;H20R1203其最高工作电压1200V，最大集电极电流20A；H20R1203其最高工作电压1000V，最大集电极电流40A等。</p><img src="/posts/203927772/image-20240413165900612.png" class="" title="image-20240413165900612"><p>还有其它其参数，比如饱和压降越小越好，压降越小管子的功耗越低；工作温度范围越宽越好，比如商业级元器件工作温度0℃<del>70℃，工业级元器件-40℃</del>85℃，汽车级元器件-40℃<del>125℃，军工级元器件-55℃</del>125℃，从温度范围也可以看出，商业级元器件性能最差，军工级最高！还有开关频率等。</p><p><strong>总结：</strong><br>元器件选型也是设计能力的体现，元器件的质量直接影响产品的功能、性能。电磁炉整流桥和IGBT选型时，没有必然的匹配关系，可根据相关参数独立选取，对于整流桥而言关键参数为工作电压、工作电流、功率等，相关参数满足即可；对于功率管IGBT而言，关键参数为最高工作电压和最大工作电流，其次还有饱和压降、工作频率、工作温度等，参数满足即可。</p><hr><h1 id="相关链接（侵删）"><a href="#相关链接（侵删）" class="headerlink" title="相关链接（侵删）"></a>相关链接（侵删）</h1><ol><li><a href="https://mp.weixin.qq.com/s/OHDhzf0jJzHoHa9lP9N5PQ">电磁炉电路主要元器件，整流桥和TGBT不用必须相互匹配？</a></li></ol><hr><center><font color=red>=================我是分割线=================</font></center><p><strong>欢迎到公众号来唠嗑:</strong></p><img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">]]></content>
    
    
    <summary type="html">电磁炉主要元器件</summary>
    
    
    
    <category term="电磁炉" scheme="https://zml3589110.github.io/categories/%E7%94%B5%E7%A3%81%E7%82%89/"/>
    
    <category term="器件" scheme="https://zml3589110.github.io/categories/%E5%99%A8%E4%BB%B6/"/>
    
    
    <category term="电磁炉" scheme="https://zml3589110.github.io/tags/%E7%94%B5%E7%A3%81%E7%82%89/"/>
    
    <category term="主要元器件" scheme="https://zml3589110.github.io/tags/%E4%B8%BB%E8%A6%81%E5%85%83%E5%99%A8%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>电磁炉保护及检测单元电路</title>
    <link href="https://zml3589110.github.io/posts/1863675241.html"/>
    <id>https://zml3589110.github.io/posts/1863675241.html</id>
    <published>2024-04-13T06:53:20.000Z</published>
    <updated>2024-04-13T09:08:27.614Z</updated>
    
    <content type="html"><![CDATA[<h1 id="高低压检测保护电路"><a href="#高低压检测保护电路" class="headerlink" title="高低压检测保护电路"></a>高低压检测保护电路</h1><img src="/posts/1863675241/%E9%AB%98%E4%BD%8E%E5%8E%8B%E4%BF%9D%E6%8A%A4.webp" class="" title="高低压保护"><img src="/posts/1863675241/%E5%8F%8D%E5%8E%8B%E4%BF%9D%E6%8A%A4.webp" class="" title="反压保护"><img src="/posts/1863675241/%E6%B5%AA%E6%B6%8C.webp" class="" title="浪涌"><ol><li>浪涌保护电路主要是针对市电电网电压中出现的异常浪涌冲击，及时关断IGBT的工作，防止爆管而进行的保护。</li><li>浪涌保护电路的取样形式有两种，一种是在市电输入端，另一种是在+300V处。</li><li>浪涌保护电路的工作原理如图2.21所示。</li></ol><img src="/posts/1863675241/%E6%B5%AA%E6%B6%8C%E7%94%B5%E8%B7%AF%E5%8E%9F%E7%90%86.webp" class="" title="浪涌电路原理"><h1 id="电流检测电路"><a href="#电流检测电路" class="headerlink" title="电流检测电路"></a>电流检测电路</h1><ol><li><p>电流检测电路的主要作用是为单片机提供整机的精确电流参数，让单片机根据此参数判断锅具加热面积的大小、是否有锅；同时，检测整机的工作电流，并以此参数进行输出功率的闭环控制。</p></li><li><p>电流检测电路主要由电流互感器CT1、全波整流桥D10~D13、微调电阻VR1等组成，其工作原理如图2.22所示。</p></li><li><p>电流检测电路原理：电流互感器CT1二次侧的AC电压，经过D10~D13组成的桥式整流桥整流、EC5平滑后的直流电压送到CPU的I-AD口，CPU根据检测此电压信号的变化来计算电磁炉的输入电流，从而自动做出各种动作。</p></li></ol><img src="/posts/1863675241/%E7%94%B5%E6%B5%81%E4%BA%92%E6%84%9F%E5%99%A8%E7%94%B5%E8%B7%AF.webp" class="" title="电流互感器电路"><p>①检测到有锅后，将会用2s的时间来检测电流的变化，通过电流变化的差值确定锅具的材质、大小和尺寸。</p><p>②工作时，单片机时刻检测电流的变化，根据检测到的电压及电流信号，自动调整PWM,进行功率恒定处理。</p><p>③工作时，单片机时刻检测电流的变化，当电流变化过大时，做无锅具的判断。</p><p>该电流信号可以用于检测锅具和调整输出功率。标准板采用的电流互感器CT1的电流比为1：3000，电流比较大，因而其在大电流的工作时感应出来的电流特性线性度较好。VR1是10k2的可调电阻，主要通过调节此电阻值来调整因结构误差引起的功率偏差，改变电流检测的基准，达到调节电磁炉输出功率大小的目的。当VR1增大时，相应的电流检测的电压会提高。在CT1一次电流一定的情况下，CT1二次侧感应出来的电压相应提高，那么电流检测的AD值会提高，根据软件设定的恒定功率的要求，功率会相对下降。</p><p>D23为钳位保护二极管，防止当电压异常升高超过+5V时，烧毁单片机。</p><h2 id="两种采样电路"><a href="#两种采样电路" class="headerlink" title="两种采样电路"></a>两种采样电路</h2><p>电流采样单元是在电磁炉工作时提供给单片机电流采样信号的采样电路。单片机时刻检测输入电流的变化，根据检测到的电流采样信号，自动调整PWM信号，使电磁炉做输出功率的恒定处理，单片机也会根据检测电流采样信号的变化来检测电磁炉的输入电流，从而自动做出各种动作。当单片机在同步电路检测到合适的有锅具的脉冲数后，将会用0.5～2s的时间来检测电流的变化，通过电流变化的差值确定加热锅具的材质、加热面积的大小尺寸是否符合加热要求，当电流采样信号变化过大时，单片机做无锅具的判断。现在市场上主流的电磁炉电路中有两种常用的电流采样单元电路，分别是采用电流互感器采样的电流采样单元和采用电阻压降采样的电流采样单元。</p><p><strong>下面将分别介绍这两种采样电路的工作原理。</strong><br>电流采样单元是在电磁炉工作时提供给单片机电流采样信号的采样电路。单片机时刻检测输入电流的变化，根据检测到的电流采样信号，自动调整PWM信号，使电磁炉做输出功率的恒定处理，单片机也会根据检测电流采样信号的变化来检测电磁炉的输入电流，从而自动做出各种动作。当单片机在同步电路检测到合适的有锅具的脉冲数后，将会用0.5～2s的时间来检测电流的变化，通过电流变化的差值确定加热锅具的材质、加热面积的大小尺寸是否符合加热要求，当电流采样信号变化过大时，单片机做无锅具的判断。现在市场上主流的电磁炉电路中有两种常用的电流采样单元电路，分别是采用电流互感器采样的电流采样单元和采用电阻压降采样的电流采样单元。下面将分别介绍这两种采样电路的工作原理。</p><p>(1)采用电流互感器采样的电流采样单元如下图(a)所示。电流互感器CT1二次测得的交流电压，经过D10～D13组成的桥式整流器整流。经EC5平滑后的直流电压送到CPU的I-A&#x2F;D口，CPU根据此电压信号的变化来检测电磁炉的输入电流。电流互感器CT1的匝数比为1：3000，匝数比大，则其在大电流的工作时感应出来的电流线性好。VR1是0～10kΩ的可调电阻，主要用来调整因为结构误差引起的功率偏差，也可通过调节此电阻来改变电流检测的基准，达到调节电磁炉输出功率大小的目的。当VR1阻值增大时，相应的电流检测的电压会提高。在CT1初级电流一定的情况下，CT1次级感应出来的电压相应提高，程序根据A&#x2F;D口模拟量信号的变化进行相应的控制，根据软件恒功的要求，功率会相对下降。</p><img src="/posts/1863675241/%E7%94%B5%E6%B5%81%E4%BA%92%E6%84%9F%E5%99%A8%E7%94%B5%E8%B7%AF.webp" class="" title="电流互感器电路"><p>(2)采用电阻采样的电流采样单元如下图(b)所示。电阻R320是串接在IGBT管e极与电源负极之间的采样电阻，一般选取0.01Ω，使其在通过10A电流时压降达到0.1V的技术要求。比较器IC4A和外围电路组成放大系数为100倍的正向直流放大器，在VR端即可获得放大100倍后的电流采样电压，此电压送到CPU的I-A&#x2F;D口，使单片机做出相应动作。可变电阻VR作用与电流互感器采样的电流采样单元中的VR1作用相同，在此不在复述。</p><img src="/posts/1863675241/%E7%94%B5%E6%B5%81%E7%94%B5%E9%98%BB%E9%87%87%E6%A0%B7.webp" class="" title="电流电阻采样"><h2 id="电流互感器"><a href="#电流互感器" class="headerlink" title="电流互感器"></a>电流互感器</h2><p>电流检测的电路有很多，一般都是通过电流信号转化为电压信号，然后通过单片机AD口检测电压，对于大电压大电流场合一般都要降压处理后再进行检测，电流互感器就是这个原理，它利用的是电磁感应原理，将初级的大电流转换到次级的小电流的一种器件。</p><img src="/posts/1863675241/%E7%94%B5%E6%B5%81%E4%BA%92%E6%84%9F%E5%99%A81.webp" class="" title="电流互感器1"><p>电流互感器是的初级绕组匝数一般很少，串在所测量的电流的线路中，如下图是电流互感器</p><img src="/posts/1863675241/%E7%94%B5%E6%B5%81%E4%BA%92%E6%84%9F%E5%99%A82.webp" class="" title="电流互感器2"><p>电流互感器在电磁炉应用过流检测方面很广泛，如下图是某电流互感器检测电流线路一部分，它的最终目的是测试电路的工作电流，从而不断调整电磁炉功率输出，使其工作保持稳定，该电路主要由电流互感器、电阻、电容等组成。工作原理：市电经过电力互感器后再次级得到交流电压，经过整流二极管D1-D4整流后，并由电解电容MC1滤波得到较为平滑的直流电，并经R3和R4分压后得到的信号送至IC，IC检测送过来的电压大小来判断电流的大小，电压越大电流也就越大，这样IC会控制IGBT开关管的导通时间来保证功率输出的稳定。有些电流检测电路用LM339组成，比较两者电压从而输出一个信号，有些由三极管组成，通过判断高低电平来判断是否过流。</p><img src="/posts/1863675241/%E7%94%B5%E6%B5%81%E4%BA%92%E6%84%9F%E5%99%A83.webp" class="" title="电流互感器3"><h1 id="炉温、管温检测电路"><a href="#炉温、管温检测电路" class="headerlink" title="炉温、管温检测电路"></a>炉温、管温检测电路</h1><p>炉温（锅具温度）检测电路的主要作用是检测锅具的实际温度，以及防止电磁炉对锅具干烧。炉温检测电路的原理如图2.23所示，主要由热敏电阻RT2(负温度系数)、R4、电容C11及插排CN1等组成。随着热敏电阻通过陶瓷板对锅具底部温度采样，送到单片机6脚的电压也会随着温度变化而变化。单片机通过主控程序的设定值与该电压进行比较，从而做出相应的动作来控制电磁炉的温度。</p><p>管温(IGBT管温度)检测电路的主要作用是对IGBT管、高压整流全桥等的工作温度进行实际检测，防止它们因过热而烧毁。管温检测电路原理如图2.23所示，主要由热敏电阻RT1(负温度系数)、电阻R5、电容C18及插排CN3等组成。管温检测电路的工作原理和锅具检测电路的工作原理相似，只不过是检测信号输入至单片机的5脚。</p><img src="/posts/1863675241/%E7%82%89%E9%9D%A2IGBT%E6%B8%A9%E5%BA%A6%E6%A3%80%E6%B5%8B.webp" class="" title="炉面IGBT温度检测"><h1 id="电磁炉的同步电路分析"><a href="#电磁炉的同步电路分析" class="headerlink" title="电磁炉的同步电路分析"></a>电磁炉的同步电路分析</h1><p>在电磁炉的电路都存在有一个重要的单元电路，那就是同步电路，它由炉盘线圈两端的取样电阻和比较器构成。设计这个电路的目的是为了避免在线圈电流突变引起IGBT功率管集电极高压时打开，以防IGBT功率管由于高压冲击而损坏。</p><p>下面来看一个实际电磁炉的同步电路的典型应用。</p><p>在电磁炉炉盘线圈的左侧电压取样电路包括R11、R12、R17、R52，通过电阻串联分压后的A点电压，再经C17、C9高频滤波，给到LM339的第6引脚(反相输入端)。</p><p>在电磁炉炉盘线圈的右侧电压取样电路包括R13、R14、R15、R16，R18、R19、R51，通过R16与R18串联、R19与R51串联，然后并联，再于R13、R14、R15串联分压后，再R16，R18串联分压，得到的B点电压，再经C8、C9高频滤波，给到LM339的第7引脚(正相输入端)。</p><img src="/posts/1863675241/%E5%90%8C%E6%AD%A5%E7%94%B5%E8%B7%AF.webp" class="" title="同步电路"><ol><li><p>当电磁炉的开关按钮被按压，触发信号给到微处理器，微处理器发出开机信号，经震荡单元电路处理，震荡脉冲使IGBT功率管导通，炉盘线圈的感生电动势为左正右负，A点电压&gt;B点电压，即:反相输入端电压＞正相输入端电压，LM339的第1引脚输出端低电平。</p></li><li><p>当IGBT功率管被关断，炉盘线圈的感生电动势为右正左负，A点电压＜B点电压，即:反相输入端电压＜正相输入端电压，LM339的第1引脚输出端高电平。</p></li><li><p>在炉盘线圈的感生电动势右正左负给谐振电容充电，到谐振电容充电完成，再到谐振电容放电给炉盘线圈的初期，B点电压＞A点电压，LM339的第1引脚输出端始终输出高电平。</p></li><li><p>当谐振电容放电给炉盘线圈的电流减小，炉盘线圈的感生电动势突变为左正右负，A点电压&gt;B点电压，即:反相输入端电压＞正相输入端电压，LM339的第1引脚输出端低电平，这时作用于震荡单元电路，使震荡单元电路输出高电平脉冲IGBT再次导通，进入下一个周期。</p></li></ol><p><strong>总结一下:</strong></p><ul><li>炉盘线圈的感生电动势为左正右负，A点电压&gt;B点电压，LM339的第1引脚输出端低电平，震荡单元电路输出高电平，IGBT导通；</li><li>在炉盘线圈的感生电动势右正左负，B点电压＞A点电压，LM339的第1引脚输出端输出高电平，震荡单元电路输出低电平，IGBT处于关断状态。</li><li>防止在高压期间打开，由于高压冲击造成IGBT损坏。</li></ul><h1 id="电磁炉IGBT驱动电路解析"><a href="#电磁炉IGBT驱动电路解析" class="headerlink" title="电磁炉IGBT驱动电路解析"></a>电磁炉IGBT驱动电路解析</h1><p><strong>在同步单元电路协同下，震荡单元电路输出相对应的占空比方波脉冲驱动由图腾柱组成的推挽电路，再由其来驱动IGBT的导通与截止。</strong></p><ol><li>当震荡单元电路输出高电平，由于S8050是NPN三极管导通，S8550PNP三极管截止，首先经S8050的基极、发射极、R35、R48、R49、接地构成电流回路。</li></ol><img src="/posts/1863675241/IGBT%E9%A9%B1%E5%8A%A8%E7%94%B5%E8%B7%AF1.webp" class="" title="IGBT驱动电路1"><ol start="2"><li>18V经S8050的集电极、发射极、R35、R48加到IGBT功率管的栅极，给栅极与发射极极间电容充电，使栅极与发射极形成高电平。</li></ol><img src="/posts/1863675241/IGBT%E9%A9%B1%E5%8A%A8%E7%94%B5%E8%B7%AF2.webp" class="" title="IGBT驱动电路2"><ol start="3"><li>整流后L1、C4滤波后，在C4形成310V平滑直流，经炉盘线圈、IGBT的集电极、发射极、接地、回到C4负，构成电流回路，给炉盘线圈储能。</li></ol><img src="/posts/1863675241/IGBT%E9%A9%B1%E5%8A%A8%E7%94%B5%E8%B7%AF3.webp" class="" title="IGBT驱动电路3"><ol start="4"><li>当震荡单元电路输出低电平(接地0V)，S8050是NPN三极管截止，S8550PNP三极管导通，首先IGBT的栅极与发射极的极间电容所存电荷，经R48、S8550的发射极、基极、震荡单元电路输出端，构成电流回路。图示箭头→</li></ol><img src="/posts/1863675241/IGBT%E9%A9%B1%E5%8A%A8%E7%94%B5%E8%B7%AF4.webp" class="" title="IGBT驱动电路4"><ol start="5"><li>栅极与发射极的极间电容所存电荷，经R48、S8550的发射极、集电极、接地，构成极间电容放电电流回路。将IGBT的栅极拉低为低电平，IGBT集电极到发射极变为截止。</li></ol><img src="/posts/1863675241/IGBT%E9%A9%B1%E5%8A%A8%E7%94%B5%E8%B7%AF5.webp" class="" title="IGBT驱动电路5"><h1 id="反压保护电路"><a href="#反压保护电路" class="headerlink" title="反压保护电路"></a>反压保护电路</h1><blockquote><p>准确的说是IGBT功率管ce极高压保护，当IGBT功率管ce极电压超过设定值，该电路输出给震荡单元电路，震荡单元电路输出的调制脉冲占空比降低，IGBT功率管导通时间缩短，截止时间变长，使IGBT功率管8ce极高压值回到额定范围内，防止因IGBT功率管ce极电压过高而造成IGBT功率管损坏。</p></blockquote><img src="/posts/1863675241/%E5%8F%8D%E5%8E%8B%E4%BF%9D%E6%8A%A4%E7%94%B5%E8%B7%AF.webp" class="" title="反压保护电路"><p>该电路包括R13、R14、R15、R16、R18、R51、R19、LM339的U2C比较器、R20、R21、R22组成。</p><p>首先LM339的U2C比较器的第9脚引正相输入端的电压是一个固定值，由R20、R21电阻串联分压得到，为:20&#x2F;(20+3.9)*5&#x3D;4.18V。</p><p>LM339的U2C比较器的第8脚引反相输入端的电压是IGBT功率管集电极(C)电压R13、R14、R15、R16、R18、R51、R19按图中的串并联关系在C点得到电压，</p><p>当C点电压低于4.18V，LM339的第14引脚U2C比较器的输出端输出为高阻态；</p><p>当C点电压高于4.18V，LM339的第14引脚U2C比较器的输出端输出为低电平(0V)。</p><p>接下来反推一下当C点为4.18时的IGBT功率管集电极、发射极间电压。</p><ul><li><p>R13、R14、R15三个电阻串联后的阻值为240+240+240&#x3D;720；</p></li><li><p>R16、R18串联后的电阻值为240+27&#x3D;267；</p></li><li><p>R51、R19串联后的电阻值为240+5.6&#x3D;245.6；</p></li><li><p>R16、R18串联，R51、R19串联再并联后的电阻值为1&#x2F;((1&#x2F;267)+(1&#x2F;245.6))&#x3D;127.9266485；</p></li></ul><p>R13、R14、R15、R16、R18、R51、R19串并联后的阻值为720+127.9266485&#x3D;847.9266485；</p><p>R51、R19串联分压，C点的电压为4.18V，B点的电压为4.18*245.6&#x2F;5.6&#x3D;183.3228571；</p><p>A点的电压为183.3228571*847.9266485&#x2F;127.9266485&#x3D;1215.1052；</p><p><strong>得出结论:</strong><br>当IGBT功率管ce极电压高于1215.1052V，LM339的第14引脚U2C比较器的输出端输出为低电平(0V)，经R22并联到震荡单元电路的正相输入端，<br>使震荡单元电路(U2D)正相输入端的电压下降，输出驱动脉冲的占空比降低，IGBT功率管导通时间缩短，截止时间变长，<br>使IGBT功率管8ce极高压值回到额定范围内，防止因IGBT功率管ce极电压过高而造成IGBT功率管损坏。</p><h1 id="震荡驱动单元电路"><a href="#震荡驱动单元电路" class="headerlink" title="震荡驱动单元电路"></a>震荡驱动单元电路</h1><blockquote><p>该电路是在同步单元电路、脉宽调制协同下，由比较器输出对应占空比方波脉冲，使IGBT功率管有序开关。</p></blockquote><img src="/posts/1863675241/%E6%8C%AF%E8%8D%A1%E7%94%B5%E8%B7%AF1.webp" class="" title="振荡电路1"><ol><li>PWM是根据使用者所选择的档位，对应的功率，微处理器所发出的对应占空比方波信号，首先经R23、EC5、C11进行低通滤波，形成平滑的直流，再叠加在由R25、R24串联分压组成的静态工作点上(2.5V)给到LM339的第11引脚(U2D的正相输入端)，该电压在某一档位下是一个相对固定值的电压(最小值＞2.5V)，在平面坐标系中，为平行横轴的直线。</li></ol><img src="/posts/1863675241/%E6%8C%AF%E8%8D%A1%E7%94%B5%E8%B7%AF2.webp" class="" title="振荡电路2"><ol start="2"><li>下面是一个锯齿波发生电路，它的构成下图所示。当C点获得一个短暂低电平(0V)触发脉冲(开机信号)，A点会是低电平，由于C6的两端电压不能突变，B点的电压也是低电平。B点的电压是给到LM339的第10引脚(U2D的反相输入端)，由于U2D的正相输入端电压＞反相输入端电压，U2D输出端为高电平(严谨的说为高阻态通过上拉电阻R33上接18V输出高电平)驱动由8050和8550组成的图腾电路，图腾电路再驱动IGBT功率管导通，LM339的U2B输出端会变成持续低电平(缘由可以参看前期的《电磁炉并联谐振的震荡过程》及《电磁炉的同步单元电路解析》)，18V通过R28给C6定时电容充电，随着C6定时电容充电，C6右端的电压会逐渐升高，即:B点电压升高，LM339的第10引脚(U2D的反相输入端)的电压会升高。</li></ol><img src="/posts/1863675241/%E6%8C%AF%E8%8D%A1%E7%94%B5%E8%B7%AF3.webp" class="" title="振荡电路3"><p>当LM339的第10引脚(U2D的反相输入端)的电压大于＞第11引脚(U2D的正相输入端)的电压，LM339的第13引脚(U2D的输出端输出低电平，由8050和8550组成的图腾电路，下管导通接地，IGBT功率管栅极变为低电平，IGBT功率管截止，炉盘线圈的感生电动势变为右正左负，同步单元电路的U2B输出端变为高阻态。(详细技术细节请前期的《电磁炉并联谐振的震荡过程》及《电磁炉的同步单元电路解析》)；C6计时电容由于D17钳位作用而放电或者说5V经R26、R27给C6电容反向充电，使C6计时电容两端差变小，最高为0.7V(左端为5v,右端为5.7v)。当炉盘线圈和谐振电容间的谐振使炉盘线圈的感生电动势变为左正右负时，同步单元电路的U2B输出端变为低电平(0V)，由于C6两端电压不能突变，即C6两端电压差为0.7V，使C6左端电压变为0V，逐使C6右端电压为0.7V，与其相连的B点的电压，LM339的第10引脚(U2D的反相输入端)电压也为0.7V，由于U2D的正相输入端电压＞反相输入端电压，U2D输出端为高电平(严谨的说为高阻态通过上拉电阻R33上接18V输出高电平)驱动由8050和8550组成的图腾电路，图腾电路再驱动IGBT功率管导通，进入下一个周期。</p><img src="/posts/1863675241/%E6%8C%AF%E8%8D%A1%E7%94%B5%E8%B7%AF4.webp" class="" title="振荡电路4"><h1 id="5V电源电路"><a href="#5V电源电路" class="headerlink" title="5V电源电路"></a>5V电源电路</h1><h2 id="电磁炉5V电源输出电压，测量结果显示312V？"><a href="#电磁炉5V电源输出电压，测量结果显示312V？" class="headerlink" title="电磁炉5V电源输出电压，测量结果显示312V？"></a>电磁炉5V电源输出电压，测量结果显示312V？</h2><blockquote><p>如果没有测错地方，那一定是电磁炉5V电源的地方发生了故障。</p></blockquote><p>电磁炉的型号很多，其内部原理设计也是多种多样，针对电磁炉的5V电源系统而言，常的有以下几种设计方式：220V交流电经过变压器转换为低压交流电然后整流、滤波，再经过7805进行稳压；有的经过变压器降压、整流、滤波，先经过7812得到12V，然后再经过7805得到5V；有的经过变压器降压、整流，然后经过限流电阻+稳压管的方式得到5V电源；有的是将220V交流电直接整流然后通过开关管脉宽调制的方式得到（采用开关电源的原理）；有的直接采用容阻降压的方式+整流+限流电阻+5V稳压管的方式得到5V电源。</p><img src="/posts/1863675241/5V%E7%94%B5%E8%B7%AF1.webp" class="" title="5V电路1"><p><strong>电磁炉5V电源系统主要给比较器及驱动芯片等供电，负载电流一般不大，有些电磁炉为了节约成本，直接采用限流电阻+稳压管的方式降压稳压。</strong></p><img src="/posts/1863675241/5V%E7%94%B5%E8%B7%AF2.webp" class="" title="5V电路2"><img src="/posts/1863675241/5V%E7%94%B5%E8%B7%AF3.webp" class="" title="5V电路3"><p>如上图容阻降压方式原理，无论是图1或图2当5V稳压管开路时，测量5V电源都是约311V左右。因为当稳压管开路时，桥式整流和半波整流输出端相当于开路（空载），无论是桥式整流还是半波整流，滤波后空载输出电压约交流电的1.414倍，即220V×1.414≈311V。虽然有容阻降压模块，但是因为没有负载电流，所以容阻降压部分几乎没有压降，整流前端的电压依然为220V，所以整流滤波后空载电压约为311V，符合提问者所测试得的312V电压，估计该电磁炉5V电源采用的原理和该原理类似，稳压管已开路。</p><h1 id="18V电源电路"><a href="#18V电源电路" class="headerlink" title="18V电源电路"></a>18V电源电路</h1><h2 id="电磁炉的基本原理"><a href="#电磁炉的基本原理" class="headerlink" title="电磁炉的基本原理"></a>电磁炉的基本原理</h2><blockquote><p>电磁炉主要由线圈盘、主控电路板、风扇、按键显示面板、陶瓷面板、上下壳等组成，其中主控电路板主要主要元器件有滤波电容、谐振电容、抗干扰电容、大功率IGBT开关管、整流桥、互感线圈、蜂鸣器、变压器、驱动芯片、LM339、8050&#x2F;8550三极管等。</p></blockquote><p>电磁炉的基本工作原理是：炉盘线圈工作电压约300V左右，300V的直流高压是220V交流电经过整流桥整流得到的，220V交流整流后最高电压为220V*1.414≈311V。其高压主回路是220VAC经过保险丝、电流互感器、电感、炉盘线圈、IGBT，通过控制IGBT开关管导通&#x2F;断开来控制炉盘线圈是否工作。IGBT控制方式一般采用PWM调制，通过调节PWM的占空比来调节电磁炉的功率，其它功能还包括功率控制、温度控制、无锅检测、电压报警、电流过大报警、IGBT温度过高报警、锅底温度过高报警、风扇故障报警等，其基本原理框图如下图所示。</p><img src="/posts/1863675241/18V%E7%94%B5%E8%B7%AF1.webp" class="" title="18V电路1"><p>下图为某款电磁炉详细原理图，关注公众号“电路一点通” 回复 进群 .其主要的电源电压有输入端220V，内部电压有300V，电磁炉功率主回路，给炉盘线圈供电；5V，控制芯片、蜂鸣器等供电；18V或15V或12V；不同型号电磁炉其电压不同，主要用于驱动IGBT开关管以及为风扇提供电源。</p><img src="/posts/1863675241/18V%E7%94%B5%E8%B7%AF2.webp" class="" title="18V电路2"><h2 id="18V电源是怎么来的呢？"><a href="#18V电源是怎么来的呢？" class="headerlink" title="18V电源是怎么来的呢？"></a>18V电源是怎么来的呢？</h2><p>了解了电磁炉的基本原理之后，下面重点说一下18V电源的原理，以其中一款电磁炉原理进行详细说明，其原理如下图所示，18V电源是由220V交流电经过变压器进行降压，再通过一个整流二极管进行半波整流，然后经过220μF&#x2F;35V的电容进行滤波，最后通过串联510Ω的限流电阻再并联18V的稳压管，将最后输出电压稳定在18V，有的电磁炉直接使用三端稳压器7818进行稳压。</p><img src="/posts/1863675241/18V%E7%94%B5%E8%B7%AF3.webp" class="" title="18V电路3"><p>同理，5V电源的原理也类似，如上图，经过变压器次级线圈降压后的低压交流电经过4个二极管组成的桥式整流电路整流，然后经过470μF&#x2F;25V的电容滤波，最后通过三端稳压器7805进行降压稳压得到5V电源。</p><p>那么没有具体电路板原理图的情况下怎么快速找到18V电源部分呢？如下图，紧贴散热器的那两个元器件，三个引脚的为IGBT开关管，四个引脚的为整流桥，找到小功率变压器，这就是提供5V、18V电源的变压器，因此附近这部分电路就是5V、18V电源电路，如下图红圈标识的地方。</p><img src="/posts/1863675241/18V%E7%94%B5%E8%B7%AF4.webp" class="" title="18V电路4"><p><strong>注意：18V电源并不是直接连接IGBT驱动端，而是经过由NPN和PNP三极管8050、8550组成的对管来驱动IGBT，因为这样才可以通过控制8050、8550导通&#x2F;截止实现PWM调制，调节电磁炉的功率。</strong></p><img src="/posts/1863675241/18V%E7%94%B5%E8%B7%AF5.webp" class="" title="18V电路5"><h2 id="18V电源故障怎么检修？"><a href="#18V电源故障怎么检修？" class="headerlink" title="18V电源故障怎么检修？"></a>18V电源故障怎么检修？</h2><p>18V电源的负载：风扇和IGBT驱动，若是因为测量IGBT无驱动电压，并不代表18V电源故障，极有可能是用于驱动IGBT的8050&#x2F;8550三极管故障，由8050、8550组成的三极管对管是易坏器件。最好测量IGBT附近的NPN三极管8050的集电极对地的电压，若无18V输出，确实极有可能是18V电源部分故障。</p><p>若18V电源输出输出不正常，先将后端负载去除再测量，有可能是负载短路引起。先把风扇插头拔掉，再测量，若输出正常，是由于风扇故障引起，可检查一下风扇扇叶是否被其它异物卡住？若没有，可能是马达故障，购买一个新的换上。若去掉负载输出仍不正常，可详细检查一下电源转换部分电路，先量一下变压器二侧线圈是否有大于18V的交流电输出，然后再检查整流二极管是否故障？限流电阻是否烧断？18V稳压二极管是否正常等。</p><p><strong>总结：</strong>电磁炉内部一般有三种电压：300V、5V、18V（或12V、15V）。若想学习电磁炉维修，最好多研究一下电磁炉的详细原理，熟悉电路板每个元器件的功能，了解电磁炉常见的故障模式，哪些属于易损坏器件等。</p><hr><h1 id="相关链接（侵删）"><a href="#相关链接（侵删）" class="headerlink" title="相关链接（侵删）"></a>相关链接（侵删）</h1><ol><li><a href="https://mp.weixin.qq.com/s/OHDhzf0jJzHoHa9lP9N5PQ">电磁炉保护及检测单元电路</a></li><li><a href="https://mp.weixin.qq.com/s/auqbp_ztNRHopcbQIOxByQ">电磁炉的同步电路分析</a></li><li><a href="https://mp.weixin.qq.com/s/BBzcq0jF0QYg3IJOfJAqtw">电磁炉IGBT驱动电路解析</a></li><li><a href="https://mp.weixin.qq.com/s/mHb9GH2kfYDQ2R3PLYIzXQ">电磁炉的高压保护电路解析</a></li><li><a href="https://mp.weixin.qq.com/s/LdLcGNN3u8QwU9BnYJggfQ">电磁炉的震荡驱动单元电路解析</a></li><li><a href="https://mp.weixin.qq.com/s/LYNYp0nQuURfOddS-1o9lw">电磁炉电流2种采样电路图</a></li><li><a href="https://mp.weixin.qq.com/s/Tnl7FY51pYIVWRlc6Faq5A">电磁炉5V电源输出电压，测量结果显示312V？</a></li><li><a href="https://mp.weixin.qq.com/s/tDB03qYvsxJeJvS06DakLQ">电磁炉18V电源故障怎么检修（电磁炉详细原理图）</a></li></ol><hr><center><font color=red>=================我是分割线=================</font></center><p><strong>欢迎到公众号来唠嗑:</strong></p><img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">]]></content>
    
    
    <summary type="html">电磁炉常用电路，主要是看到有电流互感器CT1电路分享</summary>
    
    
    
    <category term="电磁炉" scheme="https://zml3589110.github.io/categories/%E7%94%B5%E7%A3%81%E7%82%89/"/>
    
    <category term="电路" scheme="https://zml3589110.github.io/categories/%E7%94%B5%E8%B7%AF/"/>
    
    <category term="保护" scheme="https://zml3589110.github.io/categories/%E4%BF%9D%E6%8A%A4/"/>
    
    
    <category term="电磁炉" scheme="https://zml3589110.github.io/tags/%E7%94%B5%E7%A3%81%E7%82%89/"/>
    
    <category term="检测" scheme="https://zml3589110.github.io/tags/%E6%A3%80%E6%B5%8B/"/>
    
    <category term="保护" scheme="https://zml3589110.github.io/tags/%E4%BF%9D%E6%8A%A4/"/>
    
    <category term="电流" scheme="https://zml3589110.github.io/tags/%E7%94%B5%E6%B5%81/"/>
    
    <category term="同步电路" scheme="https://zml3589110.github.io/tags/%E5%90%8C%E6%AD%A5%E7%94%B5%E8%B7%AF/"/>
    
    <category term="IGBT驱动电路" scheme="https://zml3589110.github.io/tags/IGBT%E9%A9%B1%E5%8A%A8%E7%94%B5%E8%B7%AF/"/>
    
    <category term="反压保护" scheme="https://zml3589110.github.io/tags/%E5%8F%8D%E5%8E%8B%E4%BF%9D%E6%8A%A4/"/>
    
    <category term="振荡电路" scheme="https://zml3589110.github.io/tags/%E6%8C%AF%E8%8D%A1%E7%94%B5%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>davfs连接WebDav常见问题</title>
    <link href="https://zml3589110.github.io/posts/2420949935.html"/>
    <id>https://zml3589110.github.io/posts/2420949935.html</id>
    <published>2024-04-11T12:42:20.000Z</published>
    <updated>2024-04-11T13:26:21.475Z</updated>
    
    <content type="html"><![CDATA[<h1 id="（超级重要）阿里云盘通过-rsync-传输失败"><a href="#（超级重要）阿里云盘通过-rsync-传输失败" class="headerlink" title="（超级重要）阿里云盘通过 rsync 传输失败"></a>（超级重要）阿里云盘通过 rsync 传输失败</h1><h2 id="问题一：无法复制到云盘目录"><a href="#问题一：无法复制到云盘目录" class="headerlink" title="问题一：无法复制到云盘目录"></a>问题一：无法复制到云盘目录</h2><p>在前面装好 alist 且通过 davfs 连接 WebDAV 完成后，以为一切顺风顺水来着。<br>因为自己测试了几个小文件复制都能正常上传。<br>直到备份 docker 大文件有2.7G左右的时候，一直复制不成功</p><p>最开始是发现使用 rsync 将压缩文件发送到相应位置时，总提示IO异常，是因为内存问题，排查发现是系统硬盘不够，他在传送时会先放到 <strong>&#x2F;var&#x2F;cache&#x2F;davfs2</strong> 目录下，几次不成功以后，就一直缓存下来，直至把硬盘内存占满！这是之后使用文件查询工具一步步才排查出来！</p><p>系统硬盘占用率过高，通过 以下 命令针对每个文件见查询发现的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du -sh /var/cache/davfs2/* |sort -nr</span><br></pre></td></tr></table></figure><p>锁定问题就好办，其实可以直接清除，不过后边做了软链接，将这个地址指向外接硬盘上来了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">命令：ln -s /path/to/original_file /path/to/symlink</span><br><span class="line">结果：在/path/to/目录下创建一个名为symlink的软连接，该连接指向/path/to/original_file文件。</span><br></pre></td></tr></table></figure><p><strong>注：这两个linux方法后边再开新的一篇</strong></p><h2 id="问题二：无法上传到云盘内"><a href="#问题二：无法上传到云盘内" class="headerlink" title="问题二：无法上传到云盘内"></a>问题二：无法上传到云盘内</h2><p>上边问题解决了以后，以为可以顺利备份了，谁知道文件复制到云盘文件夹以后却不上传到云端，开始以为是 WebDAV 的问题，查了好多地方也没找到解决办法，然后又怀疑起了 alist 的问题，认为是没有开启大文件导致，但压根就没找到地方。</p><p>搜索一圈都没找到解决方案，也在快要放弃时看到了几篇文章，才找到问题根源。</p><h3 id="1-付费求alist百度网盘rclone挂载webdav可上传大文件方案"><a href="#1-付费求alist百度网盘rclone挂载webdav可上传大文件方案" class="headerlink" title="1.付费求alist百度网盘rclone挂载webdav可上传大文件方案"></a>1.<a href="https://github.com/alist-org/alist/discussions/4859">付费求alist百度网盘rclone挂载webdav可上传大文件方案</a></h3><p>这个还特地下载了 rclone 来尝试，其实只是解决了问题一，就是能正常复制到云盘文件夹</p><img src="/posts/2420949935/image-20240411210824151.png" class="" title="image-20240411210824151"><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rclone sync <span class="string">&#x27;/mnt/aaaa&#x27;</span> <span class="string">&#x27;baidu:/bbbbb&#x27;</span> --buffer-size=256M --use-mmap -v --transfers 1 --timeout 60m</span><br></pre></td></tr></table></figure><p>这个办法虽然没有解决这个问题，但从评论看知道了超时没多大作用，也就是说问题不在这儿。</p><h3 id="2-（根据这个解决了问题）阿里云盘通过-rsync-传输失败"><a href="#2-（根据这个解决了问题）阿里云盘通过-rsync-传输失败" class="headerlink" title="2.（根据这个解决了问题）阿里云盘通过 rsync 传输失败"></a>2.（根据这个解决了问题）<a href="https://github.com/alist-org/alist/issues/5512">阿里云盘通过 rsync 传输失败</a></h3><img src="/posts/2420949935/image-20240411211209863.png" class="" title="image-20240411211209863"><p>从这个问题描述来看，基本跟目前遇到的问题一模一样<br><strong>以下就是给出的解决方案，经过验证，完全可行：</strong></p><img src="/posts/2420949935/image-20240411211316808.png" class="" title="image-20240411211316808"><p>从中可以看出来真正的问题出在了 davfs2 上，折腾一圈这才是问题关键！</p><ul><li><strong>这依然为客户端超时取消了上传。请使用支持设置超时时间的客户端并设置超时时间。rsync并不是客户端 davfs2才是</strong></li></ul><p><strong>解决方法：调整 davfs2 配置参数 read_timeout 从默认的30 (seconds) 为7200之后，确实可以上传成功。</strong></p><p>该文件位置为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/davfs2/davfs2.conf</span><br></pre></td></tr></table></figure><hr><h1 id="相关链接（侵删）"><a href="#相关链接（侵删）" class="headerlink" title="相关链接（侵删）"></a>相关链接（侵删）</h1><ol><li><a href="https://github.com/alist-org/alist/issues/5512">docker版本挂载夸克上传文件会在5分钟超时</a></li><li><a href="https://github.com/alist-org/alist/issues/5403">阿里云盘 dav上传反复失败</a></li></ol><hr><center><font color=red>=================我是分割线=================</font></center><p><strong>欢迎到公众号来唠嗑:</strong></p><img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">]]></content>
    
    
    <summary type="html">davfs连接WebDav的一些常见问题</summary>
    
    
    
    <category term="WebDAV" scheme="https://zml3589110.github.io/categories/WebDAV/"/>
    
    <category term="davfs2" scheme="https://zml3589110.github.io/categories/davfs2/"/>
    
    <category term="alist" scheme="https://zml3589110.github.io/categories/alist/"/>
    
    
    <category term="linux" scheme="https://zml3589110.github.io/tags/linux/"/>
    
    <category term="debain" scheme="https://zml3589110.github.io/tags/debain/"/>
    
    <category term="webdav" scheme="https://zml3589110.github.io/tags/webdav/"/>
    
    <category term="ubuntu" scheme="https://zml3589110.github.io/tags/ubuntu/"/>
    
    <category term="alist" scheme="https://zml3589110.github.io/tags/alist/"/>
    
    <category term="davfs2" scheme="https://zml3589110.github.io/tags/davfs2/"/>
    
    <category term="共享" scheme="https://zml3589110.github.io/tags/%E5%85%B1%E4%BA%AB/"/>
    
    <category term="mnt" scheme="https://zml3589110.github.io/tags/mnt/"/>
    
    <category term="rsync" scheme="https://zml3589110.github.io/tags/rsync/"/>
    
    <category term="cp" scheme="https://zml3589110.github.io/tags/cp/"/>
    
  </entry>
  
  <entry>
    <title>在ubuntu上挂载WebDAV</title>
    <link href="https://zml3589110.github.io/posts/2683898239.html"/>
    <id>https://zml3589110.github.io/posts/2683898239.html</id>
    <published>2024-04-08T02:12:20.000Z</published>
    <updated>2024-04-11T13:23:34.848Z</updated>
    
    <content type="html"><![CDATA[<h1 id="alist安装挂载"><a href="#alist安装挂载" class="headerlink" title="alist安装挂载"></a>alist安装挂载</h1><ul><li>参考选择:<br><a href="https://www.iplaysoft.com/alist.html">AList 白嫖网盘空间神器 - 免费开源挂载百度&#x2F;阿里&#x2F;OneDrive等云盘到本地工具</a></li></ul><p><a href="https://blog.csdn.net/dragonballs/article/details/135384413">网盘可以当本地硬盘用？没错！使用Alist挂载云盘到本地Linux系统方法</a><br><strong>备注：参考这个使用davfs2挂载没成功，不过安装alist步骤可以参考</strong></p><h1 id="WebDAV挂载"><a href="#WebDAV挂载" class="headerlink" title="WebDAV挂载"></a>WebDAV挂载</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install davfs2</span><br></pre></td></tr></table></figure><h2 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i <span class="string">&#x27;s/# use_locks       1/use_locks       0/g&#x27;</span> /etc/davfs2/davfs2.conf</span><br></pre></td></tr></table></figure><ul><li>保存用户名密码，以后挂载的时候不会要求输入用户名密码！</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;你的WebDAV地址 用户名 密码&quot;</span> &gt;&gt; /etc/davfs2/secrets</span><br></pre></td></tr></table></figure><p>挂载</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -t davfs &lt;WebDAV地址&gt; &lt;挂载目录&gt;</span><br></pre></td></tr></table></figure><p>例如<code>mount -t davfs https://ena.teracloud.jp/dav/ /TeraCloud</code></p><ul><li>注意：挂载目录必须提前创建好</li></ul><h2 id="可能遇到的报错"><a href="#可能遇到的报错" class="headerlink" title="可能遇到的报错"></a>可能遇到的报错</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">报错 /sbin/mount.davfs:user &lt;username&gt; must be member of group davfs2</span><br></pre></td></tr></table></figure><ul><li>这个错误提示意味着在尝试使用 mount.davfs 工具挂载 WebDAV 文件共享时，当前用户 不属于 davfs2 用户组。在使用 mount.davfs 工具挂载 WebDAV 文件共享时，需要具有足够的权限才能访问 WebDAV 服务器上的共享资源，因此必须将当前用户添加到 davfs2 用户组中。</li></ul><ol><li><p>确认用户帐户 还没有属于 <code>davfs2</code> 用户组。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groups ldh</span><br></pre></td></tr></table></figure></li><li><p>如果 <code>davfs2</code> 不在当前用户的<a href="https://so.csdn.net/so/search?q=%E7%94%A8%E6%88%B7%E7%BB%84&spm=1001.2101.3001.7020">用户组</a>列表中，则需要将其添加到该列表中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -a -G davfs2 ldh</span><br></pre></td></tr></table></figure></li><li><p>重新登录以使更改生效。可以注销并重新登录，也可以使用以下命令重新启动 <code>mount.davfs</code> 以使更改生效：</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart davfs2</span><br></pre></td></tr></table></figure><p>现在，可以使用 <code>mount.davfs</code> 工具挂载 WebDAV <a href="https://so.csdn.net/so/search?q=%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB&spm=1001.2101.3001.7020">文件共享</a>了。</p></li></ol><h1 id="Linux通过安装davfs2来挂载webdav网盘"><a href="#Linux通过安装davfs2来挂载webdav网盘" class="headerlink" title="Linux通过安装davfs2来挂载webdav网盘"></a>Linux通过安装davfs2来挂载webdav网盘</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>什么是<code>webdav</code>，是一组基于超文本传输协议的技术集合，有利于用户间协同编辑和管理存储在万维网服务器文档。国外的很多网盘，包括<code>owncloud</code>都支持<code>webdav</code>,本文以<code>yandex</code>为例子介绍，挂载在<code>Linux</code>上。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>Linux</strong></p><ul><li><code>davfs2</code>或者<code>fusedav</code>将<code>WebDAV</code>共享挂载成<code>Coda</code>或者<code>FUSE</code>文件系统。</li><li><code>KDE</code>将<code>WebDAV</code>作为<code>kio_http</code>的一部分提供原生支持。<code>Dolphin</code>，<code>Konqueror</code>等其他<code>KDE</code>应用程序可以直接与<code>WebDAV</code>服务器交互。</li><li><code>Nautilus</code>也提供内置支持。</li><li><code>cadaver</code>命令行工具提供类<code>FTP</code>命令集，也包含在很多<code>Linux</code>发行版中。</li><li><code>Apache HTTP</code>服务 提供基于<code>davfs</code>和<code>Apache Subversion</code>的<code>WebDAV</code>模块。</li></ul><p><strong>Windows</strong></p><ul><li><code>NetDrive</code>：挂载为网络硬盘机</li></ul><p><strong>Mac</strong></p><ul><li><code>Finder</code>：系统内置程式</li></ul><p>本文就是利用<code>davfs2</code>挂载<code>wendav</code>。</p><h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><p><code>Linux</code>主要的源中都有<code>davfs2</code>,也可以自己编译，需要准备好环境。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">apt-get install davfs2</span><br><span class="line">mkdir /mnt/webdav</span><br><span class="line">mount -t davfs https://webdav.yandex.ru /mnt/webdav</span><br><span class="line">Please enter the username to authenticate with server</span><br><span class="line">https://webdav.yandex.ru or hit enter <span class="keyword">for</span> none.</span><br><span class="line">  Username: <span class="built_in">test</span></span><br><span class="line">Please enter the password to authenticate user <span class="built_in">test</span> with server</span><br><span class="line">https://webdav.yandex.ru or hit enter <span class="keyword">for</span> none.</span><br><span class="line">  Password:</span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>可以把账号密码写入配置文件，以普通用户来挂载。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod -a -G network username</span><br></pre></td></tr></table></figure><p>编辑<code>/etc/fstab</code>文件，在后面添加（<code>username</code>自己替换）:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;webdav.example.com &#x2F;home&#x2F;username&#x2F;webdav davfs user,noauto,uid&#x3D;username,file_mode&#x3D;600,dir_mode&#x3D;700 0 1</span><br></pre></td></tr></table></figure><p>创建账号密码配置:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~&#x2F;.davfs2&#x2F;</span><br><span class="line">echo &quot;https:&#x2F;&#x2F;webdav.example.com webdavuser webdavpassword&quot; &gt;&gt; ~&#x2F;.davfs2&#x2F;secrets </span><br><span class="line">chmod 0600 ~&#x2F;.davfs2&#x2F;secrets</span><br></pre></td></tr></table></figure><p><code>yandex url</code>是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;webdav.yandex.ru</span><br></pre></td></tr></table></figure><p>如果是<code>owncloud</code>, <code>url</code>是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;webdav.example.com&#x2F;remote.php&#x2F;webdav</span><br></pre></td></tr></table></figure><p>多用户配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;home&#x2F;username&#x2F;disk1 webdavuser1 &quot;webdavpassword1&quot;</span><br><span class="line">&#x2F;home&#x2F;username&#x2F;disk2 webdavuser1 &quot;webdavpassword2&quot;</span><br><span class="line">.........</span><br><span class="line">&#x2F;home&#x2F;username&#x2F;diskN webdavuserN &quot;webdavpasswordN&quot;</span><br></pre></td></tr></table></figure><p>Now you should be able to mount and unmount ~&#x2F;webdav:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount ~&#x2F;webdav</span><br></pre></td></tr></table></figure><p>取消挂载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fusermount -u ~&#x2F;webdav</span><br></pre></td></tr></table></figure><h2 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h2><p>如果在复制剪切文件遇到错误，编辑<code>/etc/davfs2/davfs2.conf</code>，修改配置如下，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[...]</span><br><span class="line">use_locks 0</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure><p>一个动漫网站：<a href="https://www.leimulamu.com/cn">蕾姆拉姆网</a></p><hr><h1 id="相关链接（侵删）"><a href="#相关链接（侵删）" class="headerlink" title="相关链接（侵删）"></a>相关链接（侵删）</h1><ol><li><a href="https://blog.csdn.net/qq_66623299/article/details/134733329">（参考了这个在玩客云上挂载成功）在ubuntu上挂载WebDAV</a></li><li><a href="https://www.moerats.com/archives/317/">Linux通过安装davfs2来挂载webdav网盘</a></li></ol><hr><center><font color=red>=================我是分割线=================</font></center><p><strong>欢迎到公众号来唠嗑:</strong></p><img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">]]></content>
    
    
    <summary type="html">通过安装 davfs2 完成将 alist 挂载到指定目录</summary>
    
    
    
    <category term="WebDAV" scheme="https://zml3589110.github.io/categories/WebDAV/"/>
    
    <category term="davfs2" scheme="https://zml3589110.github.io/categories/davfs2/"/>
    
    <category term="alist" scheme="https://zml3589110.github.io/categories/alist/"/>
    
    
    <category term="linux" scheme="https://zml3589110.github.io/tags/linux/"/>
    
    <category term="debain" scheme="https://zml3589110.github.io/tags/debain/"/>
    
    <category term="webdav" scheme="https://zml3589110.github.io/tags/webdav/"/>
    
    <category term="ubuntu" scheme="https://zml3589110.github.io/tags/ubuntu/"/>
    
    <category term="alist" scheme="https://zml3589110.github.io/tags/alist/"/>
    
    <category term="davfs2" scheme="https://zml3589110.github.io/tags/davfs2/"/>
    
    <category term="共享" scheme="https://zml3589110.github.io/tags/%E5%85%B1%E4%BA%AB/"/>
    
    <category term="mnt" scheme="https://zml3589110.github.io/tags/mnt/"/>
    
  </entry>
  
  <entry>
    <title>Linux命令SSH连接其他linux</title>
    <link href="https://zml3589110.github.io/posts/4056013172.html"/>
    <id>https://zml3589110.github.io/posts/4056013172.html</id>
    <published>2024-03-19T01:22:20.000Z</published>
    <updated>2024-03-19T01:37:35.929Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>1、linux服务器下一般都会安装<strong>ssh服务</strong>，<strong>ssh服务可以建立安全的远程连接</strong>，方便日常通过一台linux设备维护其他的服务器设备。</p><p>2、SSH是一种网络协议，用于计算机之间的加密登录。如果一个用户从本地计算机，使用SSH协议登录另一台远程计算机，我们就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。最早的时候，互联网通信都是明文通信，一旦被截获，内容就暴露无疑。1995年，芬兰学者Tatu Ylonen设计了SSH协议，将登录信息全部加密，成为互联网安全的一个基本解决方案，迅速在全世界获得推广，目前已经成为Linux系统的标准配置。</p><p>3、SSH之所以能够保证安全，原因在于它采用了公钥加密。整个过程是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（1）远程主机收到用户的登录请求，把自己的公钥发给用户。</span><br><span class="line">（2）用户使用这个公钥，将登录密码加密后，发送回来。</span><br><span class="line">（3）远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。</span><br></pre></td></tr></table></figure><h1 id="安装SSH服务"><a href="#安装SSH服务" class="headerlink" title="安装SSH服务"></a>安装SSH服务</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1、如果你用的是redhat，fedora，centos等系列linux发行版，那么敲入以下命令：</span><br><span class="line">sudo yum install sshd 或</span><br><span class="line">sudo yum install openssh-server（由osc网友 火耳提供）</span><br><span class="line"> </span><br><span class="line">2、如果你使用的是debian，ubuntu，linux mint等系列的linux发行版，那么敲入以下命令：</span><br><span class="line">sudo apt-get install sshd 或</span><br><span class="line">sudo apt-get install openssh-server（由osc网友 火耳提供）</span><br><span class="line"> </span><br><span class="line">然后按照提示，安装就好了。</span><br></pre></td></tr></table></figure><p>由于本机在之前就已经安装好了SSH服务，所以提示如下：</p><img src="/posts/4056013172/2289881-20220418093146937-1569352766.png" class="" title="img"><h2 id="开启SSH服务"><a href="#开启SSH服务" class="headerlink" title="开启SSH服务"></a>开启SSH服务</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service sshd start</span><br></pre></td></tr></table></figure><p>执行命令结果如下：</p><img src="/posts/4056013172/2289881-20220418093344586-1343415066.png" class="" title="img"><h2 id="卸载SSH服务"><a href="#卸载SSH服务" class="headerlink" title="卸载SSH服务"></a>卸载SSH服务</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、如果你用的是redhat，fedora，centos等系列linux发行版，那么敲入以下命令：</span><br><span class="line">yum remove sshd</span><br><span class="line">2、如果你使用的是debian，ubuntu，linux mint等系列的linux发行版，那么敲入以下命令：</span><br><span class="line">sudo apt-get –purge remove sshd</span><br></pre></td></tr></table></figure><p>执行命令结果如下：</p><img src="/posts/4056013172/2289881-20220418093521296-1553651543.png" class="" title="img"><h1 id="Linux操作系统从一台服务器SSH远程连接至另一台服务器"><a href="#Linux操作系统从一台服务器SSH远程连接至另一台服务器" class="headerlink" title="Linux操作系统从一台服务器SSH远程连接至另一台服务器"></a>Linux操作系统从一台服务器SSH远程连接至另一台服务器</h1><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><p>直接连接远程主机端口</p><p>前提条件：</p><p>两台服务器A、B；当前所在位置：服务器A；SSH服务已安装。</p><p>判断：</p><p>在服务器A中执行命令 ping B的IP地址 ，在能ping通的前提条件下</p><p>进入服务器A后，输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -l 主机名 IP</span><br></pre></td></tr></table></figure><ol><li>主机名：要跳转的Linux服务器的主机名</li><li>IP：要跳转的Linux服务器的ip地址</li></ol><p>或者：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh 用户名@服务器地址</span><br></pre></td></tr></table></figure><p>然后回车输入服务器B的用户密码就可以跳转到另一台服务器B。如 ssh <a href="mailto:&#x72;&#x6f;&#x6f;&#x74;&#64;&#49;&#50;&#55;&#46;&#48;&#x2e;&#48;&#46;&#x31;">&#x72;&#x6f;&#x6f;&#x74;&#64;&#49;&#50;&#55;&#46;&#48;&#x2e;&#48;&#46;&#x31;</a> </p><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><p>1、假定你要以用户名user，登录远程主机host，只要一条简单命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ssh username@remote_host </span><br><span class="line">如：ssh pika@192.168.0.111</span><br></pre></td></tr></table></figure><p>2、如果本地主机用户名与远程主机用户名一致，登录时可以省略用户名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ssh remote_host </span><br><span class="line">如：ssh 192.168.0.111</span><br></pre></td></tr></table></figure><p>3、SSH服务的默认端口是22：你的登录请求会送进远程主机的22端口。使用p参数，可以修改这个端口。（指定端口连接）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh username@remote_host -p 2222</span><br><span class="line">如：$ ssh user@host -p 2222   该条命令表示，ssh直接连接远程主机的2222端口。</span><br></pre></td></tr></table></figure><p>4、第一次登录远程主机：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">如果你是第一次登录对方主机</span><br><span class="line"></span><br><span class="line">$ ssh root@12.18.429.21</span><br><span class="line"></span><br><span class="line">系统会出现下面的提示：：</span><br><span class="line"></span><br><span class="line">The authenticity of host &#39;host (12.18.429.21)&#39; can&#39;t be established.</span><br><span class="line"></span><br><span class="line">RSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d.</span><br><span class="line"></span><br><span class="line">Are you sure you want to continue connecting (yes&#x2F;no)?</span><br><span class="line"></span><br><span class="line">这段话的意思是，无法确认host主机的真实性，只知道它的公钥指纹，问你还想继续连接吗？</span><br><span class="line"></span><br><span class="line">所谓&quot;公钥指纹&quot;，是指公钥长度较长（这里采用RSA算法，长达1024位），很难比对，所以对其进行MD5计算，将它变成一个128位的指纹。上例中是98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d，再进行比较，就容易多了。</span><br><span class="line"></span><br><span class="line">很自然的一个问题就是，用户怎么知道远程主机的公钥指纹应该是多少？回答是没有好办法，远程主机必须在自己的网站上贴出公钥指纹，以便用户自行核对。</span><br><span class="line"></span><br><span class="line">假定经过风险衡量以后，用户决定接受这个远程主机的公钥。</span><br><span class="line"></span><br><span class="line">Are you sure you want to continue connecting (yes&#x2F;no)? yes</span><br><span class="line"></span><br><span class="line">系统会出现一句提示，表示host主机已经得到认可。</span><br><span class="line"></span><br><span class="line">Warning: Permanently added &#39;host,12.18.429.21&#39; (RSA) to the list of known hosts.</span><br><span class="line"></span><br><span class="line">然后，会要求输入密码。</span><br><span class="line"></span><br><span class="line">Password: (enter password)</span><br><span class="line"></span><br><span class="line">如果密码正确，就可以登录了。</span><br><span class="line"></span><br><span class="line">当远程主机的公钥被接受以后，它就会被保存在文件$HOME&#x2F;.ssh&#x2F;known_hosts之中。下次再连接这台主机，系统就会认出它的公钥已经保存在本地了，从而跳过警告部分，直接提示输入密码。</span><br><span class="line"></span><br><span class="line">每个SSH用户都有自己的known_hosts文件，此外系统也有一个这样的文件，通常是&#x2F;etc&#x2F;ssh&#x2F;ssh_known_hosts，保存一些对所有用户都可信赖的远程主机的公钥。</span><br></pre></td></tr></table></figure><h2 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h2><p>1、使用密码登录，用户每次都必须输入密码，非常麻烦。好在SSH还提供了公钥登录，可以省去输入密码的步骤。</p><p>2、所谓”公钥登录”，原理很简单，就是用户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。</p><p>3、这种方法要求用户必须提供自己的公钥。如果没有现成的，可以直接用 ssh-keygen 命令生成一个：</p><p>运行上面的命令以后，系统会出现一系列提示，可以一路回车。其中有一个问题是，要不要对私钥设置口令（passphrase），如果担心私钥的安全，这里可以设置一个。</p><img src="/posts/4056013172/2289881-20220623094705926-812029543.png" class="" title="img"><p>运行结束以后，在$HOME&#x2F;.ssh&#x2F;目录下，会新生成两个文件：id_rsa.pub和id_rsa。前者是你的公钥，后者是你的私钥。 </p><img src="/posts/4056013172/2289881-20220623095047939-4098033.png" class="" title="img"><p>4、这时再输入下面的命令，将公钥传送到远程主机host上面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-copy-id user@host</span><br></pre></td></tr></table></figure><p>好了，从此你再登录，就不需要输入密码了。</p><p>5、如果还是不行，就打开远程主机的 &#x2F;etc&#x2F;ssh&#x2F;sshd_config 这个文件，检查下面几行前面”#”注释是否取掉。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RSAAuthentication yes</span><br><span class="line"></span><br><span class="line">PubkeyAuthentication yes</span><br><span class="line"></span><br><span class="line">AuthorizedKeysFile .ssh&#x2F;authorized_keys</span><br></pre></td></tr></table></figure><p>然后，重启远程主机的ssh服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; ubuntu系统</span><br><span class="line"></span><br><span class="line">service ssh restart</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; debian系统</span><br><span class="line"></span><br><span class="line">&#x2F;etc&#x2F;init.d&#x2F;ssh restart</span><br></pre></td></tr></table></figure><h2 id="示例4"><a href="#示例4" class="headerlink" title="示例4"></a>示例4</h2><p>通过密钥连接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -i path&#x2F;to&#x2F;key_file username@remote_host</span><br></pre></td></tr></table></figure><h2 id="示例5"><a href="#示例5" class="headerlink" title="示例5"></a>示例5</h2><p>ssh跳板:通过跳板机器连接远程主机；多个跳板使用逗号隔开</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -J username@jump_host username@remote_host</span><br></pre></td></tr></table></figure><h2 id="实例6"><a href="#实例6" class="headerlink" title="实例6"></a>实例6</h2><p>本实例的客户端和服务端均为Ubuntu操作系统。</p><p>ssh客户端：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用户名(user_name): alpha</span><br><span class="line">IP地址(client_ip): 192.168.0.33</span><br></pre></td></tr></table></figure><p>ssh服务端：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用户名(user_name): omega</span><br><span class="line">IP地址(server_ip): 119.9.90.190</span><br></pre></td></tr></table></figure><h2 id="ssh服务器远程登录"><a href="#ssh服务器远程登录" class="headerlink" title="ssh服务器远程登录"></a>ssh服务器远程登录</h2><h3 id="1-普通登录-ssh-user-name-server-ip"><a href="#1-普通登录-ssh-user-name-server-ip" class="headerlink" title="1 普通登录: ssh user_name@server_ip"></a>1 普通登录: <code>ssh user_name@server_ip</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[alpha@客户端] :~$ ssh omega@119.9.90.190</span><br><span class="line">输入omega@119.9.90.190的密码:</span><br><span class="line">loading omega@119.9.90.190 ...</span><br><span class="line">welcome!</span><br><span class="line">[omega@服务端] :~$ </span><br></pre></td></tr></table></figure><h3 id="2-免ip登录-ssh-Host"><a href="#2-免ip登录-ssh-Host" class="headerlink" title="2 免ip登录: ssh Host"></a>2 免ip登录: <code>ssh Host</code></h3><h4 id="2-1-客户端alpha用户进入隐藏ssh目录"><a href="#2-1-客户端alpha用户进入隐藏ssh目录" class="headerlink" title="2.1 客户端alpha用户进入隐藏ssh目录"></a>2.1 客户端alpha用户进入隐藏ssh目录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[alpha@客户端] :~$ cd ~&#x2F;.ssh</span><br><span class="line">[alpha@客户端] :~&#x2F;.ssh$ pwd</span><br><span class="line">&#x2F;home&#x2F;exia&#x2F;.ssh </span><br></pre></td></tr></table></figure><h4 id="2-2-新建-x2F-修改config文件-sudo-vim-config"><a href="#2-2-新建-x2F-修改config文件-sudo-vim-config" class="headerlink" title="2.2 新建&#x2F;修改config文件: sudo vim config"></a>2.2 新建&#x2F;修改config文件: <code>sudo vim config</code></h4><p>config文件单元构成:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host: 登录名</span><br><span class="line">----HostName: 将要登录ssh服务器ip</span><br><span class="line">----User: 将要登录服务器用户名</span><br><span class="line">----Port: 将要登录服务器端口</span><br></pre></td></tr></table></figure><p>config文件中可以设置多个Host：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[alpha@客户端] :~$ cat config</span><br><span class="line">Host omi</span><br><span class="line">    HostName 119.9.90.190</span><br><span class="line">    User omega</span><br><span class="line">    Port 22</span><br><span class="line"></span><br><span class="line">Host theroot</span><br><span class="line">     HostName 119.9.90.190</span><br><span class="line">    User root</span><br><span class="line">    Port 22</span><br></pre></td></tr></table></figure><h4 id="2-3-实现免ip登录"><a href="#2-3-实现免ip登录" class="headerlink" title="2.3 实现免ip登录"></a>2.3 实现免ip登录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[alpha@客户端] :~$ ssh omi</span><br><span class="line"></span><br><span class="line">输入omega@119.9.90.190的密码:</span><br><span class="line">loading omega@119.9.90.190 ...</span><br><span class="line">welcome!</span><br><span class="line"></span><br><span class="line">[omega@服务端] :~$ </span><br></pre></td></tr></table></figure><h3 id="3-免密登录-ssh-i-id-rsa-Host-和-ssh-Host"><a href="#3-免密登录-ssh-i-id-rsa-Host-和-ssh-Host" class="headerlink" title="3 免密登录: ssh -i id_rsa Host 和 ssh Host"></a>3 免密登录: <code>ssh -i id_rsa Host</code> 和 <code>ssh Host</code></h3><h4 id="3-1-客户端alpha用户进入隐藏ssh目录"><a href="#3-1-客户端alpha用户进入隐藏ssh目录" class="headerlink" title="3.1 客户端alpha用户进入隐藏ssh目录"></a>3.1 客户端alpha用户进入隐藏ssh目录</h4><h4 id="3-2-生成ssh登录密钥与公钥-若之前未生成"><a href="#3-2-生成ssh登录密钥与公钥-若之前未生成" class="headerlink" title="3.2 生成ssh登录密钥与公钥(若之前未生成)"></a>3.2 生成ssh登录密钥与公钥(若之前未生成)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[alpha@客户端] :~&#x2F;.ssh$ ls</span><br><span class="line">config</span><br><span class="line">[alpha@客户端] :~&#x2F;.ssh$ ssh-keygen</span><br><span class="line">[alpha@客户端] :~&#x2F;.ssh$ ls</span><br><span class="line">config  id_rsa  id_rsa.pub</span><br></pre></td></tr></table></figure><h4 id="3-3-将公钥发送给需要免密登录的服务器的用户"><a href="#3-3-将公钥发送给需要免密登录的服务器的用户" class="headerlink" title="3.3 将公钥发送给需要免密登录的服务器的用户"></a>3.3 将公钥发送给需要免密登录的服务器的用户</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[alpha@客户端] :~&#x2F;.ssh$ ssh-copy-id omega@119.9.90.190;echo &quot;ssh-copy-id omi 也行&quot;</span><br><span class="line">ssh-copy-id omi 也行</span><br><span class="line">[alpha@客户端] :~&#x2F;.ssh$ echo &quot;开始免密登录&quot;</span><br><span class="line"># 开始免密登录</span><br><span class="line">[alpha@客户端] :~&#x2F;.ssh$ </span><br><span class="line">[alpha@客户端] :~&#x2F;.ssh$ </span><br><span class="line">[alpha@客户端] :~&#x2F;.ssh$ ssh -i id_rsa omi</span><br><span class="line">loading omega@119.9.90.190 ...</span><br><span class="line">welcome!</span><br><span class="line"></span><br><span class="line">[omega@服务端] :~$ cd ~&#x2F;.ssh</span><br><span class="line">[omega@服务端] :~&#x2F;.ssh$ ls</span><br><span class="line">authorized_keys</span><br></pre></td></tr></table></figure><p>此时,<code>[omega@服务端] :~/.ssh/authorized_keys </code>中已经存放了<code>[alpha@客户端] :~/.ssh/id_rsa.pub</code>中的公钥了。</p><p>当然直接打开<code>[alpha@客户端] :~/.ssh/id_rsa.pub</code> 将其中的内容复制粘贴到 <code>[omega@服务端] :~/.ssh/authorized_keys</code> 中最后一行也是可以的。</p><h4 id="3-4-最后-在config文件中各Host的最后添加IdentityFile-ssh-id-rsa"><a href="#3-4-最后-在config文件中各Host的最后添加IdentityFile-ssh-id-rsa" class="headerlink" title="3.4 最后, 在config文件中各Host的最后添加IdentityFile ~/.ssh/id_rsa:"></a>3.4 最后, 在config文件中各Host的最后添加<code>IdentityFile ~/.ssh/id_rsa</code>:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[alpha@客户端] :~$ cat config</span><br><span class="line">Host omi</span><br><span class="line">    HostName 119.9.90.190</span><br><span class="line">    User omega</span><br><span class="line">    Port 22</span><br><span class="line">    IdentityFile ~&#x2F;.ssh&#x2F;id_rsa</span><br><span class="line"></span><br><span class="line">Host theroot</span><br><span class="line">     HostName 119.9.90.190</span><br><span class="line">    User root</span><br><span class="line">    Port 22</span><br><span class="line">    IdentityFile ~&#x2F;.ssh&#x2F;id_rsa</span><br></pre></td></tr></table></figure><p>即可进一步简化ssh远程登录命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[alpha@客户端] :~&#x2F;.ssh$ ssh omi</span><br><span class="line">loading omega@119.9.90.190 ...</span><br><span class="line">welcome!</span><br><span class="line"></span><br><span class="line">[omega@服务端] :~$ </span><br></pre></td></tr></table></figure><p>如果服务端相应免密用户的密码或是用户名有更改, 需要对客户端中对应用户~&#x2F;.ssh下:</p><p>(1)修改config中Host的信息<br>(2)删除<code>known hosts</code>文件</p><h1 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h1><h2 id="补充1：不用输入ssh-i命令行即可携带pem文件快速登录的方法"><a href="#补充1：不用输入ssh-i命令行即可携带pem文件快速登录的方法" class="headerlink" title="补充1：不用输入ssh -i命令行即可携带pem文件快速登录的方法"></a>补充1：不用输入ssh -i命令行即可携带pem文件快速登录的方法</h2><p>1、如果要登录的Linux服务器只允许pem认证。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -i ~&#x2F;.ssh&#x2F;id_rsa.pub azureuser@10.111.12.123</span><br></pre></td></tr></table></figure><p>其中的  -i 选项表明，选择一个和公钥匹配的私钥文件路径。默认是~&#x2F;.ssh&#x2F;id_rsa。</p><p>2、但是每次输入 ssh -i xxxx.pem 用户@ip 地址  就很烦。</p><p>3、有个一劳永逸的方法：</p><p>进入到自己的用户目录，例如&#x2F;home&#x2F;me</p><p>把.pem文件放在当前目录</p><p>然后vi .ssh&#x2F;config</p><p>内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Host *</span><br><span class="line">      ServerAliveInterval 60</span><br><span class="line">  Host denglu</span><br><span class="line">      HostName 你的ip</span><br><span class="line">      User mojie</span><br><span class="line">      IdentityFile    ~&#x2F;.ssh&#x2F;你的pem文件名.pem</span><br></pre></td></tr></table></figure><p>保存后，更改权限： sudo chmod 600 key.pem </p><p>然后在当前目录&#x2F;home&#x2F;me下输入 ssh denglu</p><p>即可登录到目标服务器。再也不用每次输入长长的命令了</p><h2 id="补充2：Linux操作系统中的路径符号"><a href="#补充2：Linux操作系统中的路径符号" class="headerlink" title="补充2：Linux操作系统中的路径符号"></a>补充2：Linux操作系统中的路径符号</h2><img src="/posts/4056013172/2289881-20220623100305140-2101043131.png" class="" title="img"><h2 id="补充3：-exit-退出远程连接服务器，回到本机的命令终端"><a href="#补充3：-exit-退出远程连接服务器，回到本机的命令终端" class="headerlink" title="补充3： exit 退出远程连接服务器，回到本机的命令终端"></a>补充3： exit 退出远程连接服务器，回到本机的命令终端</h2><img src="/posts/4056013172/2289881-20220922143253118-1107541336.png" class="" title="img"><hr><h1 id="相关链接（侵删）"><a href="#相关链接（侵删）" class="headerlink" title="相关链接（侵删）"></a>相关链接（侵删）</h1><ol><li><a href="https://www.cnblogs.com/hls-code/p/16158324.html">Linux操作系统如何使用SSH命令连接另外一台Linux服务器</a></li><li><a href="https://blog.csdn.net/pipisorry/article/details/52269785">ssh用法及命令</a></li></ol><hr><center><font color=red>=================我是分割线=================</font></center><p><strong>欢迎到公众号来唠嗑:</strong></p><img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;1、linux服务器下一般都会安装&lt;strong&gt;ssh服务&lt;/strong&gt;，&lt;strong&gt;ssh服务可以建立安全的远程连接&lt;/stro</summary>
      
    
    
    
    <category term="Linux" scheme="https://zml3589110.github.io/categories/Linux/"/>
    
    <category term="ssh" scheme="https://zml3589110.github.io/categories/ssh/"/>
    
    <category term="ssh-keygen" scheme="https://zml3589110.github.io/categories/ssh-keygen/"/>
    
    
    <category term="Ubuntu" scheme="https://zml3589110.github.io/tags/Ubuntu/"/>
    
    <category term="linux" scheme="https://zml3589110.github.io/tags/linux/"/>
    
    <category term="ssh" scheme="https://zml3589110.github.io/tags/ssh/"/>
    
    <category term="控制其他linux" scheme="https://zml3589110.github.io/tags/%E6%8E%A7%E5%88%B6%E5%85%B6%E4%BB%96linux/"/>
    
    <category term="远程登录" scheme="https://zml3589110.github.io/tags/%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95/"/>
    
    <category term="秘钥" scheme="https://zml3589110.github.io/tags/%E7%A7%98%E9%92%A5/"/>
    
    <category term="id_rsa.pub公钥" scheme="https://zml3589110.github.io/tags/id-rsa-pub%E5%85%AC%E9%92%A5/"/>
    
    <category term="id_rsa秘钥" scheme="https://zml3589110.github.io/tags/id-rsa%E7%A7%98%E9%92%A5/"/>
    
    <category term="ssh-keygen" scheme="https://zml3589110.github.io/tags/ssh-keygen/"/>
    
  </entry>
  
  <entry>
    <title>Linux定时任务</title>
    <link href="https://zml3589110.github.io/posts/2711669357.html"/>
    <id>https://zml3589110.github.io/posts/2711669357.html</id>
    <published>2024-03-12T02:05:20.000Z</published>
    <updated>2024-03-19T01:37:35.939Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>如果需要在主机定时或周期启动或运行某一程序或脚本，由于程序或脚本运行的时长并不确定，可能会出现同时重复运行多个该程序或脚本的情况。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="CentOS"><a href="#CentOS" class="headerlink" title="CentOS"></a>CentOS</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yuminstall vixie-cron crontabs &#x2F;&#x2F;安装Crontab</span><br><span class="line">chkconfigcrondon &#x2F;&#x2F;设为开机自启动</span><br><span class="line">service crondstart &#x2F;&#x2F;启动</span><br></pre></td></tr></table></figure><h3 id="Debian-注：平时直接用以下-x2F-etc…-中的cron命令"><a href="#Debian-注：平时直接用以下-x2F-etc…-中的cron命令" class="headerlink" title="Debian(注：平时直接用以下&#x2F;etc… 中的cron命令)"></a>Debian(注：平时直接用以下&#x2F;etc… 中的cron命令)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-getinstall cron &#x2F;&#x2F;大部分情况下Debian都已安装。</span><br><span class="line">&#x2F;etc&#x2F;init.d&#x2F;cron restart &#x2F;&#x2F;重启Crontab</span><br></pre></td></tr></table></figure><h2 id="定时任务目录"><a href="#定时任务目录" class="headerlink" title="定时任务目录"></a><a href="https://so.csdn.net/so/search?q=%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1&spm=1001.2101.3001.7020">定时任务</a>目录</h2><table><thead><tr><th align="left">目录路径</th><th align="left">执行说明</th></tr></thead><tbody><tr><td align="left">&#x2F;etc&#x2F;cron.hourly</td><td align="left">系统定时任务周期每小时执行该目录下的脚本</td></tr><tr><td align="left">&#x2F;etc&#x2F;cron.daily</td><td align="left">系统定时任务周期每一天执行该目录下的脚本</td></tr><tr><td align="left">&#x2F;etc&#x2F;cron.weekly</td><td align="left">系统定时任务周期每一周执行该目录下的脚本</td></tr><tr><td align="left">&#x2F;etc&#x2F;cron.monthly</td><td align="left">系统定时任务周期每个月执行该目录下的脚本</td></tr></tbody></table><p><strong>注意</strong>权限</p><p> 注意：增加.sh脚本可执行权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x ******.sh</span><br></pre></td></tr></table></figure><h2 id="定时任务文件"><a href="#定时任务文件" class="headerlink" title="定时任务文件"></a><strong>定时任务文件</strong></h2><table><thead><tr><th align="left">类型</th><th align="left">路径</th></tr></thead><tbody><tr><td align="left">全局定时任务配置文件</td><td align="left">&#x2F;etc&#x2F;crontab</td></tr><tr><td align="left">用户定时任务配置文件</td><td align="left">&#x2F;var&#x2F;spool&#x2F;cron&#x2F;root</td></tr></tbody></table><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><table><thead><tr><th align="left">基本格式</th><th align="left"></th><th align="left"></th><th align="left"></th><th align="left"></th><th align="left"></th></tr></thead><tbody><tr><td align="left">*</td><td align="left">*</td><td align="left">*</td><td align="left">*</td><td align="left">*</td><td align="left">command</td></tr><tr><td align="left">分（0-59）</td><td align="left">时（0-23）</td><td align="left">日（1-31）</td><td align="left">月（1-12）</td><td align="left">周（0-6）</td><td align="left">定时执行的命令</td></tr></tbody></table><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设定某个用户的cron服务</span></span><br><span class="line">crontab -u </span><br><span class="line"><span class="comment"># 查看定时任务</span></span><br><span class="line">crontab -l</span><br><span class="line"><span class="comment"># 设置定时任务</span></span><br><span class="line">crontab -e</span><br><span class="line"><span class="comment"># 删除定时任务</span></span><br><span class="line">crontab -r</span><br><span class="line"><span class="comment"># 查看帮助</span></span><br><span class="line">crontab -h</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 例如：root查看自己的cron设置</span></span><br><span class="line">crontab -u root -l</span><br><span class="line"><span class="comment"># 例如：root想删除fred的cron设置</span></span><br><span class="line">crontab -u fred -r</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 关闭crontab服务 </span></span><br><span class="line">systemctl stop crond </span><br><span class="line"><span class="comment"># 开启crontab服务 </span></span><br><span class="line">systemctl start crond </span><br><span class="line"><span class="comment"># 重启crontab服务</span></span><br><span class="line">systemctl restart crond</span><br><span class="line"><span class="comment"># 查看crontab服务</span></span><br><span class="line">systemctl status crond</span><br><span class="line"><span class="comment"># 重新载入crontab配置</span></span><br><span class="line">systemctl reload crond</span><br></pre></td></tr></table></figure><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>修改定时任务配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每天15：30运行一个python脚本：</span></span><br><span class="line">30 17 * * * root python -u script.py &gt; /dev/null</span><br><span class="line"><span class="comment"># 每天凌晨3:00执行备份程序：</span></span><br><span class="line">0 3 * * * /root/backup.sh</span><br><span class="line"><span class="comment"># 每周日8点30分执行日志清理程序：</span></span><br><span class="line">30 8 * * 7 /root/clear.sh</span><br><span class="line"><span class="comment"># 每周1周5 0点整执行test程序：</span></span><br><span class="line">0 0 ** 1,5 <span class="built_in">test</span></span><br><span class="line"><span class="comment"># 每年的5月12日14点执行wenchuan程序：</span></span><br><span class="line">0 14 12 5 * /root/wenchuan</span><br></pre></td></tr></table></figure><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>在实际的使用过程中可能会存在着重复启动定时程序的可能，需要对定时任务进一步改进。</p><p>flock通常会使用一个「锁文件」，也就是建立一个文件来告诉别的进程自己在运行，如果检测到那个文件存在，则认为有操作同样数据的进程在工作，这样就可以防止其它进程访问这个文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flock -xn /tmp/tmp.lock</span><br></pre></td></tr></table></figure><p>改进后的形式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 保证同时只有一个程序运行</span></span><br><span class="line">*/5 * * * * root flock -xn /tmp/tmp.lock python -u  DownLoad.py &gt; /dev/null</span><br></pre></td></tr></table></figure><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p><a href="https://link.zhihu.com/?target=https://blog.csdn.net/bandaoyu/article/details/122623607">Crontab<img src="/posts/2711669357/icon-default.png" class="" title="icon-default.png?t&#x3D;N2N8">https://link.zhihu.com/?target=https%3A//blog.csdn.net/bandaoyu/article/details/122623607</a></p><p><a href="https://www.dandelioncloud.cn/article/details/1531152954367426561">linux Crontab的安装<img src="/posts/2711669357/icon-default.png" class="" title="icon-default.png?t&#x3D;N2N8">https://www.dandelioncloud.cn/article/details/1531152954367426561</a></p><hr><h1 id="相关链接（侵删）"><a href="#相关链接（侵删）" class="headerlink" title="相关链接（侵删）"></a>相关链接（侵删）</h1><ol><li><a href="https://blog.csdn.net/yeyaozhifengqi/article/details/129793823">定时任务——Crontab</a></li><li><a href="https://www.cnblogs.com/qlsem/p/17529838.html">linux 怎么定时去执行一个 .sh 文件</a></li><li><a href="https://www.cnblogs.com/javaxubo/p/17498202.html">(相对详细)Linux新建定时任务crontab</a></li><li><a href="https://blog.csdn.net/u011754972/article/details/116143259">【Linux】23.ubuntu定时执行脚本&#x2F;etc&#x2F;crontab 和 定时任务不执行的解决办法</a></li><li><a href="https://blog.csdn.net/qq_37510195/article/details/129530014">【运维知识基础篇】Linux定时任务</a></li></ol><hr><center><font color=red>=================我是分割线=================</font></center><p><strong>欢迎到公众号来唠嗑:</strong></p><img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">]]></content>
    
    
    <summary type="html">linux下运行定时任务</summary>
    
    
    
    <category term="Linux" scheme="https://zml3589110.github.io/categories/Linux/"/>
    
    <category term="定时运行" scheme="https://zml3589110.github.io/categories/%E5%AE%9A%E6%97%B6%E8%BF%90%E8%A1%8C/"/>
    
    <category term="crond" scheme="https://zml3589110.github.io/categories/crond/"/>
    
    
    <category term="Ubuntu" scheme="https://zml3589110.github.io/tags/Ubuntu/"/>
    
    <category term="linux" scheme="https://zml3589110.github.io/tags/linux/"/>
    
    <category term="debain" scheme="https://zml3589110.github.io/tags/debain/"/>
    
    <category term="定时运行" scheme="https://zml3589110.github.io/tags/%E5%AE%9A%E6%97%B6%E8%BF%90%E8%A1%8C/"/>
    
    <category term="crond" scheme="https://zml3589110.github.io/tags/crond/"/>
    
    <category term="crontab" scheme="https://zml3589110.github.io/tags/crontab/"/>
    
  </entry>
  
  <entry>
    <title>系统时间管理</title>
    <link href="https://zml3589110.github.io/posts/1883728245.html"/>
    <id>https://zml3589110.github.io/posts/1883728245.html</id>
    <published>2024-02-20T06:55:20.000Z</published>
    <updated>2024-02-20T07:09:03.088Z</updated>
    
    <content type="html"><![CDATA[<h1 id="时区问题"><a href="#时区问题" class="headerlink" title="时区问题"></a>时区问题</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul><li>中国使用的是东八区上海时间，而linux服务器，一般默认是0时区<code>UTC</code>，所以需要将时区改为东八区<code>CST</code></li><li>将时区改为东八区后，显示的实际仍然不对，仍然差8小时或16小时，这说明时间不对</li><li>时间修改正确后，服务器重启，时间显示又错误了，因为没改硬件时钟时间</li></ul><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><ul><li>linux系统时间，与本地时间不一致，一般有两种情况</li><li>一是时区设置错误，不是当地使用时区</li><li>二是时间设置错误，未联网校时，或者人为不小心设置错了</li></ul><h2 id="处理时区问题"><a href="#处理时区问题" class="headerlink" title="处理时区问题"></a>处理时区问题</h2><h3 id="date查看时间、时区"><a href="#date查看时间、时区" class="headerlink" title="date查看时间、时区"></a>date查看时间、时区</h3><ul><li>首先查看时间是否正确，与当地时间一致，可使用以下命令</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">date</span><br><span class="line">date -R</span><br></pre></td></tr></table></figure><img src="/posts/1883728245/7bcd3ea605734ec2a141d540ef8c67b0.png" class="" title="在这里插入图片描述"><ul><li><code>date</code>查看日期时间，<code>date -R</code>则会把时区一起显示出来</li><li>可以看到上面的时间错了（与当地时间误差几分钟），下面时间虽然对了但是时区不对（应该为+0800）</li></ul><h5 id="timedatectl查看时间、时区"><a href="#timedatectl查看时间、时区" class="headerlink" title="timedatectl查看时间、时区"></a>timedatectl查看时间、时区</h5><ul><li>也可以使用<code>timedatectl</code>查看和设置时区</li></ul><img src="/posts/1883728245/97a60eafb18c441c870739b932c85cd5.png" class="" title="在这里插入图片描述"><ul><li>Local time：当前使用的时区的时间，也就是<code>date</code>命令显示的时间</li><li>Universal time：世界时间，也就是0时区时间，世界通用的协调时间</li><li>RTC time：硬件时钟时间，关机也会</li><li>Time zone：现正使用的时区，可以看到上面是<code>CST</code>，中国时区，是对的</li></ul><h5 id="查看localtime"><a href="#查看localtime" class="headerlink" title="查看localtime"></a>查看localtime</h5><ul><li>也可以直接使用<code>ls -l /etc/localtime</code>查看系统当前的时区</li></ul><img src="/posts/1883728245/112f6f3c72ce4194aa6c3740185aa8e2.png" class="" title="在这里插入图片描述"><h5 id="设置时区"><a href="#设置时区" class="headerlink" title="设置时区"></a>设置时区</h5><ul><li>第一种方式，可以通过<code>zoneinfo</code>直接设置</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br></pre></td></tr></table></figure><ul><li>第二种方式，与第一种类似，使用软连接</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br></pre></td></tr></table></figure><ul><li>第三种方式，使用<code>timedatectl</code>设置时区</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timedatectl set-timezone Asia/Shanghai</span><br></pre></td></tr></table></figure><h1 id="处理时间问题"><a href="#处理时间问题" class="headerlink" title="处理时间问题"></a>处理时间问题</h1><ul><li>如果时区已经设置对了，时间显示还是不对，可以手动设置下时间，或者使用互联网校时</li><li>需要安装<code>ntpdate</code>，再校时即可，但是需要在联网情况下进行</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install -y ntp ntpdate</span><br><span class="line">ntpdate 0.asia.pool.ntp.org</span><br><span class="line">date</span><br></pre></td></tr></table></figure><ul><li>如果没有联网，只能直接使用<code>date -s 日期 时间</code>设置了</li><li>时间显示正确后，查看下硬件时间，顺便把硬件时间也改对，防止重启失效</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hwclock --show</span><br><span class="line"><span class="meta">#</span><span class="bash"> hc代表硬件时间，sys代表系统时间，即用系统时钟同步硬件时钟</span></span><br><span class="line">hwclock --systohc  </span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 或</span></span>   </span><br><span class="line">clock --systohc  </span><br><span class="line">hwclock -w</span><br><span class="line">date</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="一、使用date命令查看系统时间"><a href="#一、使用date命令查看系统时间" class="headerlink" title="一、使用date命令查看系统时间"></a>一、使用date命令查看系统时间</h2><p>ate是Linux系统中用来显示或设置系统时间和日期的命令，常用于脚本编写、系统管理等操作中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date</span><br></pre></td></tr></table></figure><p>执行以上命令，系统将输出当前的系统时间，格式为“星期 月 日 时:分:秒 时区 年份”，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Fri Oct 15 14:56:34 CST 2021</span><br></pre></td></tr></table></figure><p>要查看特定时刻的系统时间，可以使用date命令加上时间参数。例如，要查看2021年1月1日零点的系统时间，可以使用以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date` `-d ``&quot;2021-01-01 00:00:00&quot;</span><br></pre></td></tr></table></figure><p>如果要在脚本中获取系统时间并进行操作，可以使用date命令结合格式化参数将系统时间格式化为指定格式。例如，要获取当前系统时间的小时数，可以使用以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date` `+%H</span><br></pre></td></tr></table></figure><h2 id="二、通过-x2F-var-x2F-log-x2F-syslog文件查看系统时间"><a href="#二、通过-x2F-var-x2F-log-x2F-syslog文件查看系统时间" class="headerlink" title="二、通过&#x2F;var&#x2F;log&#x2F;syslog文件查看系统时间"></a>二、通过&#x2F;var&#x2F;log&#x2F;syslog文件查看系统时间</h2><p>&#x2F;var&#x2F;log&#x2F;syslog是Linux系统中保存系统日志信息的文件，其中包含着各种系统事件的详细信息。</p><p>要查看系统启动时间，可以在&#x2F;var&#x2F;log&#x2F;syslog文件中查找“systemd[1]: Started”字符串，该字符串表示系统启动的时间。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep` `&quot;systemd[1]: Started&quot;` `/var/log/syslog</span><br></pre></td></tr></table></figure><p>执行以上命令，系统将输出包含系统启动时间的日志信息。</p><h2 id="三、通过-x2F-proc-x2F-uptime文件查看系统运行时间"><a href="#三、通过-x2F-proc-x2F-uptime文件查看系统运行时间" class="headerlink" title="三、通过&#x2F;proc&#x2F;uptime文件查看系统运行时间"></a>三、通过&#x2F;proc&#x2F;uptime文件查看系统运行时间</h2><p>&#x2F;proc&#x2F;uptime文件记录了系统从启动到当前的运行时间。</p><p>要查看系统的运行时间，可以使用以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat` `/proc/uptime</span><br></pre></td></tr></table></figure><p>系统将输出两个数字，第一个数字表示系统从启动到当前的运行时间，以秒为单位；第二个数字表示系统在空闲状态下运行的时间，以秒为单位。</p><h2 id="四、通过hwclock命令查看硬件时间"><a href="#四、通过hwclock命令查看硬件时间" class="headerlink" title="四、通过hwclock命令查看硬件时间"></a>四、通过hwclock命令查看硬件时间</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hwclock是Linux系统中用来读取和设置硬件时钟的命令。</span><br><span class="line"></span><br><span class="line">要查看硬件时间，可以使用以下命令：</span><br><span class="line">sudo hwclock --show</span><br><span class="line">执行以上命令，系统将输出当前的硬件时间。</span><br></pre></td></tr></table></figure><h2 id="五、通过timedatectl命令设置系统时区"><a href="#五、通过timedatectl命令设置系统时区" class="headerlink" title="五、通过timedatectl命令设置系统时区"></a>五、通过timedatectl命令设置系统时区</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">timedatectl是Linux系统中用来查看和设置系统时间、时区等信息的命令。</span><br><span class="line"></span><br><span class="line">要查看当前系统的时区，可以使用以下命令：</span><br><span class="line"></span><br><span class="line">timedatectl</span><br><span class="line">要设置系统的时区，可以使用以下命令：</span><br><span class="line"></span><br><span class="line">sudo timedatectl set-timezone Asia/Shanghai</span><br><span class="line">执行以上命令，将系统的时区设置为上海。</span><br></pre></td></tr></table></figure><h2 id="六、通过NTP协议同步网络时间"><a href="#六、通过NTP协议同步网络时间" class="headerlink" title="六、通过NTP协议同步网络时间"></a>六、通过NTP协议同步网络时间</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">NTP（Network Time Protocol）是一种用于同步网络时间的协议。</span><br><span class="line"></span><br><span class="line">要通过NTP协议同步网络时间，可以使用以下命令：</span><br><span class="line"></span><br><span class="line">sudo apt-get install ntp</span><br><span class="line">sudo service ntp stop</span><br><span class="line">sudo ntpdate cn.pool.ntp.org</span><br><span class="line">sudo service ntp start</span><br><span class="line">执行以上命令，系统将通过中国NTP服务器cn.pool.ntp.org同步网络时间。</span><br></pre></td></tr></table></figure><h2 id="七、通过ntpstat命令检查NTP同步状态"><a href="#七、通过ntpstat命令检查NTP同步状态" class="headerlink" title="七、通过ntpstat命令检查NTP同步状态"></a>七、通过ntpstat命令检查NTP同步状态</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ntpstat是Linux系统中用来检查NTP同步状态的命令。</span><br><span class="line"></span><br><span class="line">要检查NTP同步状态，可以使用以下命令：</span><br><span class="line"></span><br><span class="line">ntpstat</span><br><span class="line">系统将输出当前的NTP同步状态，例如：</span><br><span class="line"></span><br><span class="line">synchronised to NTP server (210.72.145.44) at stratum 2</span><br><span class="line">   time correct to within 34 ms</span><br><span class="line">   polling server every 64 s</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="八、使用cal命令查看日历"><a href="#八、使用cal命令查看日历" class="headerlink" title="八、使用cal命令查看日历"></a>八、使用cal命令查看日历</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cal是Linux系统中用来显示日历的命令。</span><br><span class="line"></span><br><span class="line">要查看当前月份的日历，可以使用以下命令：</span><br><span class="line"></span><br><span class="line">cal</span><br><span class="line">系统将输出当前月份的日历。</span><br></pre></td></tr></table></figure><h2 id="九、使用clock命令显示时钟"><a href="#九、使用clock命令显示时钟" class="headerlink" title="九、使用clock命令显示时钟"></a>九、使用clock命令显示时钟</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">clock是Linux系统中用来显示时钟的命令。</span><br><span class="line"></span><br><span class="line">要在终端中显示时钟，可以使用以下命令：</span><br><span class="line"></span><br><span class="line">watch -n1 -t &quot;date +%T&quot;</span><br><span class="line">执行以上命令，系统将每秒钟刷新一次终端中的系统时间。</span><br></pre></td></tr></table></figure><h2 id="十、总结"><a href="#十、总结" class="headerlink" title="十、总结"></a>十、总结</h2><p>本文介绍了多种Linux系统查看系统时间的方法，从date命令、系统日志文件、&#x2F;proc&#x2F;uptime文件、hwclock命令、timedatectl命令、NTP协议、ntpstat命令、cal命令、clock命令等多个方面展开阐述。这些方法既能帮助我们了解系统时间和日期，也能为脚本编写、系统管理等操作提供便利。</p><hr><h1 id="相关链接（侵删）"><a href="#相关链接（侵删）" class="headerlink" title="相关链接（侵删）"></a>相关链接（侵删）</h1><ol><li><a href="https://blog.csdn.net/u010882234/article/details/128024735">CentOS7等linux系统时区时间不对显示误差8小时</a></li><li><a href="https://www.jb51.net/jiaoben/297846gya.htm">Linux查看系统时间的详细方法总结</a></li></ol><hr><center><font color=red>=================我是分割线=================</font></center><p><strong>欢迎到公众号来唠嗑:</strong></p><img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">]]></content>
    
    
    <summary type="html">linux时间相关</summary>
    
    
    
    <category term="Linux" scheme="https://zml3589110.github.io/categories/Linux/"/>
    
    <category term="时间" scheme="https://zml3589110.github.io/categories/%E6%97%B6%E9%97%B4/"/>
    
    
    <category term="Ubuntu" scheme="https://zml3589110.github.io/tags/Ubuntu/"/>
    
    <category term="时间" scheme="https://zml3589110.github.io/tags/%E6%97%B6%E9%97%B4/"/>
    
    <category term="时区" scheme="https://zml3589110.github.io/tags/%E6%97%B6%E5%8C%BA/"/>
    
  </entry>
  
  <entry>
    <title>linux文件管理</title>
    <link href="https://zml3589110.github.io/posts/1071158144.html"/>
    <id>https://zml3589110.github.io/posts/1071158144.html</id>
    <published>2024-02-20T03:28:20.000Z</published>
    <updated>2024-02-20T06:26:08.945Z</updated>
    
    <content type="html"><![CDATA[<h1 id="查看文件夹大小"><a href="#查看文件夹大小" class="headerlink" title="查看文件夹大小"></a>查看文件夹大小</h1><h2 id="1-ls-命令：列出当前工作目录下的所有文件-x2F-文件夹的名称"><a href="#1-ls-命令：列出当前工作目录下的所有文件-x2F-文件夹的名称" class="headerlink" title="1.ls 命令：列出当前工作目录下的所有文件&#x2F;文件夹的名称"></a>1.ls 命令：列出当前工作目录下的所有文件&#x2F;文件夹的名称</h2><blockquote><p>使用ls -l，会显示成字节大小，ls- lh会以KB、MB等为单位进行显示更加直观</p></blockquote><img src="/posts/1071158144/431942-20230829100154657-1955390267.png" class="" title="img"><h2 id="2-du-命令：查看当前目录和子目录文件夹-x2F-文件大小情况"><a href="#2-du-命令：查看当前目录和子目录文件夹-x2F-文件大小情况" class="headerlink" title="2.du 命令：查看当前目录和子目录文件夹&#x2F;文件大小情况"></a>2.du 命令：查看当前目录和子目录文件夹&#x2F;文件大小情况</h2><blockquote><p>du &#x3D; disk usage 磁盘使用率，输出每个文件或者目录总大小, 其用法如下：</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du [OPTION]… [FILE]…</span><br></pre></td></tr></table></figure><ul><li>-c, –total 累计大小</li><li>-d, –max-depth&#x3D;N 决定统计每个目录的深度</li><li>-B, –block-size&#x3D;SIZE 决定显示文件大小的单位;比如 ‘-BM’，就是MB，’-BK’就是KB</li><li>-h, –human-readable 以高可读方式打印 (比如1K 234M 2G)</li><li>-s, –summarize 显示总大小</li><li><code>du -sh</code> 查看当前目录总大小。</li><li><code>du -sh *</code> 查看当前目录所有子目录大小。</li><li><code>du -ach *</code> 查看当前目录和所有子目录大小，最后一行会显示当前目录的总大小，不包括隐藏文件。</li></ul><img src="/posts/1071158144/431942-20230829100545940-391467487.png" class="" title="img"><h2 id="3-df-命令：用于显示磁盘分区上的可使用的磁盘空间"><a href="#3-df-命令：用于显示磁盘分区上的可使用的磁盘空间" class="headerlink" title="3.df 命令：用于显示磁盘分区上的可使用的磁盘空间"></a>3.df 命令：用于显示磁盘分区上的可使用的磁盘空间</h2><p><code>df = disk free</code> 命令用于显示磁盘分区上的可使用的磁盘空间。默认显示单位为KB。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。<br><code>df -h</code> 以可读性高的结果展示磁盘分区上的可使用的磁盘空间。</p><img src="/posts/1071158144/431942-20230829100620526-1595981637.png" class="" title="img"><hr><h1 id="相关链接（侵删）"><a href="#相关链接（侵删）" class="headerlink" title="相关链接（侵删）"></a>相关链接（侵删）</h1><ol><li><a href="https://www.cnblogs.com/zakun/p/linux-ls-du-df.html">查看文件夹大小</a></li></ol><hr><center><font color=red>=================我是分割线=================</font></center><p><strong>欢迎到公众号来唠嗑:</strong></p><img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">]]></content>
    
    
    <summary type="html">linux文件和文件件相关管理</summary>
    
    
    
    <category term="Linux" scheme="https://zml3589110.github.io/categories/Linux/"/>
    
    <category term="文件管理" scheme="https://zml3589110.github.io/categories/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
    
    
    <category term="Ubuntu" scheme="https://zml3589110.github.io/tags/Ubuntu/"/>
    
    <category term="文件管理" scheme="https://zml3589110.github.io/tags/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
    
    <category term="文件夹大小" scheme="https://zml3589110.github.io/tags/%E6%96%87%E4%BB%B6%E5%A4%B9%E5%A4%A7%E5%B0%8F/"/>
    
  </entry>
  
  <entry>
    <title>docker命令合集</title>
    <link href="https://zml3589110.github.io/posts/61889715.html"/>
    <id>https://zml3589110.github.io/posts/61889715.html</id>
    <published>2024-02-20T03:15:20.000Z</published>
    <updated>2024-02-20T06:26:08.953Z</updated>
    
    <content type="html"><![CDATA[<h1 id="linux管理docker"><a href="#linux管理docker" class="headerlink" title="linux管理docker"></a>linux管理docker</h1><h2 id="查看docker安装目录"><a href="#查看docker安装目录" class="headerlink" title="查看docker安装目录"></a>查看docker安装目录</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">whereis docker</span><br><span class="line">docker: /usr/bin/docker /etc/docker /usr/libexec/docker /usr/share/man/man1/docker.1.gz</span><br></pre></td></tr></table></figure><h2 id="查询运行文件所在路径"><a href="#查询运行文件所在路径" class="headerlink" title="查询运行文件所在路径"></a>查询运行文件所在路径</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">which docker</span><br><span class="line">/usr/bin/docker</span><br></pre></td></tr></table></figure><h2 id="启动docker"><a href="#启动docker" class="headerlink" title="启动docker"></a>启动docker</h2><p>Docker应用需要用到各种端口，逐一去修改防火墙设置。非常麻烦，因此建议大家直接关闭防火墙！</p><p>启动docker前，一定要关闭防火墙后！！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 关闭</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line"><span class="meta">#</span><span class="bash"> 禁止开机启动防火墙</span></span><br><span class="line">systemctl disable firewalld</span><br><span class="line"><span class="meta">#</span><span class="bash">查看是否关闭防火墙</span></span><br><span class="line">systemctl status firewalld</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">systemctl start docker  # 启动docker服务</span><br><span class="line"></span><br><span class="line">systemctl stop docker  # 停止docker服务</span><br><span class="line"></span><br><span class="line">systemctl restart docker  # 重启docker服务</span><br><span class="line"></span><br><span class="line">systemctl status docker  # 查看docker启动状态</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="配置镜像加速"><a href="#配置镜像加速" class="headerlink" title="配置镜像加速"></a>配置镜像加速</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">docker官方镜像仓库网速较差，我们需要设置国内镜像服务：</span><br><span class="line"></span><br><span class="line">参考阿里云的镜像加速文档：https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#创建文件夹</span></span></span><br><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="comment">##在文件夹内新建一个daemon.json文件</span></span></span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://akchsmlh.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#重新加载文件</span></span></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#重启docker</span></span></span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> 7.卸载</span><br><span class="line">yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-selinux \</span><br><span class="line">                  docker-engine-selinux \</span><br><span class="line">                  docker-engine \</span><br><span class="line">                  docker-ce</span><br></pre></td></tr></table></figure><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>首先需要大家虚拟机联网，安装yum工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils \</span><br><span class="line">           device-mapper-persistent-data \</span><br><span class="line">           lvm2 --skip-broken</span><br></pre></td></tr></table></figure><p>然后更新本地镜像源：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置docker镜像源</span></span><br><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">sed -i &#x27;s/download.docker.com/mirrors.aliyun.com\/docker-ce/g&#x27; /etc/yum.repos.d/docker-ce.repo</span><br><span class="line">yum makecache fast</span><br></pre></td></tr></table></figure><p>最后输入命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y docker-ce</span><br></pre></td></tr></table></figure><h1 id="docker自身命令"><a href="#docker自身命令" class="headerlink" title="docker自身命令"></a>docker自身命令</h1><h2 id="查看版本"><a href="#查看版本" class="headerlink" title="查看版本"></a>查看版本</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker -v 查看docker版本</span><br></pre></td></tr></table></figure><h2 id="镜像相关"><a href="#镜像相关" class="headerlink" title="镜像相关"></a>镜像相关</h2><p><strong>镜像列表：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p><strong>拉取镜像：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull 镜像名</span><br><span class="line">docker pull 镜像名:tag</span><br></pre></td></tr></table></figure><blockquote><p>不加tag(版本号) 即拉取docker仓库中 该镜像的最新版本latest 加:tag 则是拉取指定版本</p></blockquote><p><strong>保存镜像：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save -o redis.tar redis:latest</span><br></pre></td></tr></table></figure><blockquote><p>docker save 镜像名&#x2F;镜像ID -o 镜像保存的名字 镜像保存的tag</p></blockquote><p><strong>删除镜像：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi -f 镜像名/镜像ID</span><br></pre></td></tr></table></figure><p><strong>加载镜像：</strong><br>docker load -i 镜像保存文件位置<br>例如：docker load -i redis.ta</p><hr><h1 id="相关链接（侵删）"><a href="#相关链接（侵删）" class="headerlink" title="相关链接（侵删）"></a>相关链接（侵删）</h1><ol><li><a href="https://blog.csdn.net/lucylily11/article/details/127598805">安装docker</a></li></ol><hr><center><font color=red>=================我是分割线=================</font></center><p><strong>欢迎到公众号来唠嗑:</strong></p><img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">]]></content>
    
    
    <summary type="html">docker命令合集-一个大合集，收集些常用的命令</summary>
    
    
    
    <category term="Docker" scheme="https://zml3589110.github.io/categories/Docker/"/>
    
    <category term="命令" scheme="https://zml3589110.github.io/categories/%E5%91%BD%E4%BB%A4/"/>
    
    
    <category term="linux" scheme="https://zml3589110.github.io/tags/linux/"/>
    
    <category term="Docker" scheme="https://zml3589110.github.io/tags/Docker/"/>
    
    <category term="命令" scheme="https://zml3589110.github.io/tags/%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>docker自动备份</title>
    <link href="https://zml3589110.github.io/posts/2802299989.html"/>
    <id>https://zml3589110.github.io/posts/2802299989.html</id>
    <published>2024-02-20T02:54:20.000Z</published>
    <updated>2024-02-20T06:26:08.965Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HomeAssistant-使用插件备份"><a href="#HomeAssistant-使用插件备份" class="headerlink" title="HomeAssistant 使用插件备份"></a>HomeAssistant 使用插件备份</h1><h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h2><p> <strong>集成：</strong>Auto Backup<br> <strong>加载项：</strong><br> Alist <a href="https://gitcode.com/waxgourd/addons">https://gitcode.com/waxgourd/addons</a><br> Rclone Backup <a href="https://github.com/jcwillox/hassio-rclone-backup">https://github.com/jcwillox/hassio-rclone-backup</a></p><h2 id="2-Alist挂载阿里云网盘"><a href="#2-Alist挂载阿里云网盘" class="headerlink" title="2.Alist挂载阿里云网盘"></a>2.Alist挂载阿里云网盘</h2><p>网上有很多教程，比如挂载完得到一个webdav地址为：<strong><a href="http://192.168.101.81:5244/dav">http://192.168.101.81:5244/dav</a></strong> ，挂载的名称为 <strong>AliYunPan</strong></p><h2 id="3-配置Rclone"><a href="#3-配置Rclone" class="headerlink" title="3.配置Rclone"></a>3.配置Rclone</h2><h3 id="3-1-在-x2F-config目录下，新建一个rclone-conf的文件，编辑内容为："><a href="#3-1-在-x2F-config目录下，新建一个rclone-conf的文件，编辑内容为：" class="headerlink" title="3.1 在&#x2F;config目录下，新建一个rclone.conf的文件，编辑内容为："></a>3.1 在&#x2F;config目录下，新建一个rclone.conf的文件，编辑内容为：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[Alist]</span><br><span class="line">type = webdav</span><br><span class="line">url = http://192.168.101.81:5244/dav </span><br><span class="line">vendor = other</span><br></pre></td></tr></table></figure><p> <strong>url填Alist的webdav地址。</strong></p><h3 id="3-2-在加载项页面，修改Rclone配置为"><a href="#3-2-在加载项页面，修改Rclone配置为" class="headerlink" title="3.2 在加载项页面，修改Rclone配置为"></a>3.2 在加载项页面，修改Rclone配置为</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Sync</span> <span class="string">Daily</span> <span class="string">Backups</span></span><br><span class="line">  <span class="attr">schedule:</span> <span class="number">50</span> <span class="number">3</span> <span class="string">*</span> <span class="string">*</span> <span class="string">*</span></span><br><span class="line">  <span class="attr">command:</span> <span class="string">sync</span></span><br><span class="line">  <span class="attr">sources:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/backup</span></span><br><span class="line">  <span class="attr">destination:</span> <span class="string">Alist:/AliYunPan/haos自动备份</span>   </span><br><span class="line">  <span class="attr">include:</span> []</span><br><span class="line">  <span class="attr">exclude:</span> []</span><br><span class="line">  <span class="attr">flags:</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p> <strong>destination填写Alist的挂载的阿里云的路径</strong></p><h3 id="3-3-启动加载项，打开-WEB-UI，点击左侧菜单栏-Configs，会出现一个Alist的配置，选择-Update。"><a href="#3-3-启动加载项，打开-WEB-UI，点击左侧菜单栏-Configs，会出现一个Alist的配置，选择-Update。" class="headerlink" title="3.3 启动加载项，打开 WEB UI，点击左侧菜单栏 Configs，会出现一个Alist的配置，选择 Update。"></a>3.3 启动加载项，打开 WEB UI，点击左侧菜单栏 Configs，会出现一个Alist的配置，选择 Update。</h3><ul><li>第一步直接点击<strong>Next</strong></li><li>第二步填写Alist的webdav的账户密码，如下图，填完继续<strong>Next</strong>，就配置完成了</li></ul><img src="/posts/2802299989/150404h2dwpimzowwwc27h.png" class="" title="img"><ul><li>这时候再打开3.1那里的rclone.conf文件，就已经自动生成user和pass，pass是加密的<br> 这样Rclone就配置好了。</li></ul><h2 id="4-创建自动备份自动化"><a href="#4-创建自动备份自动化" class="headerlink" title="4.创建自动备份自动化"></a>4.创建自动备份自动化</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">alias:</span> <span class="string">自动备份</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">每天晚上3点半，自动备份文件到本地，同时上传到云端</span></span><br><span class="line"><span class="attr">trigger:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">platform:</span> <span class="string">time</span></span><br><span class="line">    <span class="attr">at:</span> <span class="string">&quot;03:30:00&quot;</span></span><br><span class="line"><span class="attr">condition:</span> []</span><br><span class="line"><span class="attr">action:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">service:</span> <span class="string">auto_backup.backup</span></span><br><span class="line">    <span class="attr">data:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">Automatic</span> <span class="string">Backup</span> &#123;&#123; <span class="string">now().strftime(&#x27;%Y-%m-%d&#x27;)</span> &#125;&#125;</span><br><span class="line">      <span class="attr">exclude_addons:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">f1549655_koolsmart*</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">a0d7b954_zerotier</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">15d21743_samba_backup</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">core_mariadb</span></span><br><span class="line">      <span class="attr">exclude_folders:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">media</span></span><br><span class="line">      <span class="attr">keep_days:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">mode:</span> <span class="string">single</span></span><br></pre></td></tr></table></figure><p>上面配置文件我排除了几个体积较大的不常用的加载项和media文件夹，这样就完成了，每天3点半系统备份，3点50同步到阿里云盘。</p><img src="/posts/2802299989/160609rmlejjxmhbjn6tbz.png" class="" title="img"><img src="/posts/2802299989/160334fkhbralbn0nqqo8q.png" class="" title="img"><h1 id="docker直接部署，没有基于ha来备份"><a href="#docker直接部署，没有基于ha来备份" class="headerlink" title="docker直接部署，没有基于ha来备份"></a>docker直接部署，没有基于ha来备份</h1><p><strong>注意：</strong><br>在此之前要使用命令找到自己docker安装位置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker info | grep &quot;Docker Root Dir&quot;</span><br></pre></td></tr></table></figure><img src="/posts/2802299989/image-20240220111050231.png" class="" title="image-20240220111050231"><p>将所有docker volume映射到一个文件夹，定时执行shell备份上传这个文件夹   </p><img src="/posts/2802299989/171625yrlrr1uflzrlbg1r.png" class="" title="img"><p>docker的数据都映射到&#x2F;usr&#x2F;mydocker下<br>webdav挂载跟楼主的方式类似，但是我用的是davfs2<br>定时运行下面的shell就行  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 本地目录变量</span></span><br><span class="line">LOCAL_BACKUP_DIR=&quot;/mnt/mydisk/backup/mydocker&quot;</span><br><span class="line">WEBDAV_MOUNT_POINT=&quot;/mnt/webdav/aliyun/备份/mydocker&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 确保本地备份目录存在</span></span><br><span class="line">mkdir -p &quot;$&#123;LOCAL_BACKUP_DIR&#125;&quot;</span><br><span class="line">mkdir -p &quot;$&#123;WEBDAV_MOUNT_POINT&#125;&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建今天的备份目录</span></span><br><span class="line">TODAY=$(date +%Y-%m-%d)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 压缩/usr/mydocker文件夹，排除photoprism</span></span><br><span class="line">tar -czvf &quot;$&#123;LOCAL_BACKUP_DIR&#125;/backup_$&#123;TODAY&#125;.tar.gz&quot; --exclude=&#x27;/usr/mydocker/photoprism&#x27; --exclude=&#x27;/usr/mydocker/emby2Alist/nginx/embyCache&#x27; /usr/mydocker</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将压缩包拷贝到WebDAV</span></span><br><span class="line">rsync -ah --progress &quot;$&#123;LOCAL_BACKUP_DIR&#125;/backup_$&#123;TODAY&#125;.tar.gz&quot; &quot;$&#123;WEBDAV_MOUNT_POINT&#125;&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在WebDAV目录中删除超过30天的旧备份文件</span></span><br><span class="line">find &quot;$&#123;WEBDAV_MOUNT_POINT&#125;&quot; -name &#x27;backup_*.tar.gz&#x27; -type f -mtime +30 -exec rm &#123;&#125; \;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在本地备份目录中也删除超过30天的旧备份文件</span></span><br><span class="line">find &quot;$&#123;LOCAL_BACKUP_DIR&#125;&quot; -name &#x27;backup_*.tar.gz&#x27; -type f -mtime +30 -exec rm &#123;&#125; \;</span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="/posts/2802299989/image-20240220110706888.png" class="" title="image-20240220110706888"><img src="/posts/2802299989/image-20240220110731063.png" class="" title="image-20240220110731063"><h1 id="自己参考更改的shell"><a href="#自己参考更改的shell" class="headerlink" title="自己参考更改的shell"></a>自己参考更改的shell</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 本地目录变量</span></span><br><span class="line">DOCKER_ROOT_DIR=&quot;/mnt/share/docker-lib/docker&quot;</span><br><span class="line">LOCAL_BACKUP_DIR=&quot;/mnt/share/mydisk/backup/mydocker&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">WEBDAV_MOUNT_POINT=<span class="string">&quot;/mnt/webdav/aliyun/备份/mydocker&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 确保本地备份目录存在</span></span><br><span class="line">mkdir -p &quot;$&#123;LOCAL_BACKUP_DIR&#125;&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">mkdir -p <span class="string">&quot;<span class="variable">$&#123;WEBDAV_MOUNT_POINT&#125;</span>&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建今天的备份目录</span></span><br><span class="line">TODAY=$(date +%Y-%m-%d)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 压缩/usr/mydocker文件夹，排除photoprism</span></span><br><span class="line">tar -czvf &quot;$&#123;LOCAL_BACKUP_DIR&#125;/backup_$&#123;TODAY&#125;.tar.gz&quot; --exclude=&#x27;$&#123;DOCKER_ROOT_DIR&#125;/photoprism&#x27; --exclude=&#x27;$&#123;DOCKER_ROOT_DIR&#125;/emby2Alist/nginx/embyCache&#x27; $&#123;DOCKER_ROOT_DIR&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将压缩包拷贝到WebDAV</span></span><br><span class="line"><span class="meta">#</span><span class="bash">rsync -ah --progress <span class="string">&quot;<span class="variable">$&#123;LOCAL_BACKUP_DIR&#125;</span>/backup_<span class="variable">$&#123;TODAY&#125;</span>.tar.gz&quot;</span> <span class="string">&quot;<span class="variable">$&#123;WEBDAV_MOUNT_POINT&#125;</span>&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在WebDAV目录中删除超过30天的旧备份文件</span></span><br><span class="line"><span class="meta">#</span><span class="bash">find <span class="string">&quot;<span class="variable">$&#123;WEBDAV_MOUNT_POINT&#125;</span>&quot;</span> -name <span class="string">&#x27;backup_*.tar.gz&#x27;</span> -<span class="built_in">type</span> f -mtime +3 -<span class="built_in">exec</span> rm &#123;&#125; \;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在本地备份目录中也删除超过30天的旧备份文件</span></span><br><span class="line">find &quot;$&#123;LOCAL_BACKUP_DIR&#125;&quot; -name &#x27;backup_*.tar.gz&#x27; -type f -mtime +30 -exec rm &#123;&#125; \;</span><br></pre></td></tr></table></figure><hr><h1 id="相关链接（侵删）"><a href="#相关链接（侵删）" class="headerlink" title="相关链接（侵删）"></a>相关链接（侵删）</h1><ol><li><a href="https://bbs.hassbian.com/thread-24005-1-1.html">自动备份到阿里云盘</a></li><li><a href="https://blog.51cto.com/u_16175443/7839734">查看Docker安装路径</a></li></ol><hr><center><font color=red>=================我是分割线=================</font></center><p><strong>欢迎到公众号来唠嗑:</strong></p><img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">]]></content>
    
    
    <summary type="html">实现对docker备份，可以直接linux级别，也可以使用 HomeAssistant 集成</summary>
    
    
    
    <category term="Docker" scheme="https://zml3589110.github.io/categories/Docker/"/>
    
    <category term="备份" scheme="https://zml3589110.github.io/categories/%E5%A4%87%E4%BB%BD/"/>
    
    
    <category term="linux" scheme="https://zml3589110.github.io/tags/linux/"/>
    
    <category term="HomeAssistant" scheme="https://zml3589110.github.io/tags/HomeAssistant/"/>
    
    <category term="Docker" scheme="https://zml3589110.github.io/tags/Docker/"/>
    
    <category term="备份" scheme="https://zml3589110.github.io/tags/%E5%A4%87%E4%BB%BD/"/>
    
    <category term="阿里云" scheme="https://zml3589110.github.io/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"/>
    
    <category term="AliYunPan" scheme="https://zml3589110.github.io/tags/AliYunPan/"/>
    
    <category term="webdav" scheme="https://zml3589110.github.io/tags/webdav/"/>
    
  </entry>
  
  <entry>
    <title>继电器相关</title>
    <link href="https://zml3589110.github.io/posts/2386778146.html"/>
    <id>https://zml3589110.github.io/posts/2386778146.html</id>
    <published>2024-02-20T01:32:20.000Z</published>
    <updated>2024-02-20T01:52:46.054Z</updated>
    
    <content type="html"><![CDATA[<h1 id="三友继电器"><a href="#三友继电器" class="headerlink" title="三友继电器"></a>三友继电器</h1><p><strong>命名：</strong></p><img src="/posts/2386778146/image-20240220093411796.png" class="" title="image-20240220093411796"><p><strong>外形：</strong></p><img src="/posts/2386778146/image-20240220093516554.png" class="" title="image-20240220093516554"><h2 id="SRD-S-112DM（一组常开4脚10A250VAC继电器12v）"><a href="#SRD-S-112DM（一组常开4脚10A250VAC继电器12v）" class="headerlink" title="SRD-S-112DM（一组常开4脚10A250VAC继电器12v）"></a>SRD-S-112DM（一组常开4脚10A250VAC继电器12v）</h2><p><a href="http://m.xgzrelay.com/p/326.html#header">三友SRD-S-112DM继电器</a></p><p><strong>产品型号：</strong>SRD-S-112DM继电器<br><strong>外形尺寸：</strong>19.6×15.4×15.5<br><strong>阳性负载：</strong>10A250VAC<br><strong>线圈功率：</strong>0.36W<br><strong>额定电压：</strong>12v<br><strong>环境温度：</strong>-40℃~ + 105℃<br><strong>适用范围：</strong>家用电器,智能家居,安防设备,照明电子,测量仪器,可穿戴设备,汽车电子,网络通信,3C数码,医疗电子,物联网IoT,新能源,军工&#x2F;航天,广电教育</p><img src="/posts/2386778146/image-20240220093647481.png" class="" title="image-20240220093647481"><img src="/posts/2386778146/image-20240220093709507.png" class="" title="image-20240220093709507"><img src="/posts/2386778146/image-20240220093722802.png" class="" title="image-20240220093722802"><h1 id="AFE-爱福继电器"><a href="#AFE-爱福继电器" class="headerlink" title="AFE 爱福继电器"></a>AFE 爱福继电器</h1><p><strong>命名：</strong></p><img src="/posts/2386778146/5bf29badd228e.jpg" class="" title="img"><p><strong>外形：</strong></p><img src="/posts/2386778146/5bf29bc2cf251.jpg" class="" title="img"><h2 id="BRD-SS-105LM-（一组常开4脚12A250VAC继电器5v）"><a href="#BRD-SS-105LM-（一组常开4脚12A250VAC继电器5v）" class="headerlink" title="BRD-SS-105LM （一组常开4脚12A250VAC继电器5v）"></a>BRD-SS-105LM （一组常开4脚12A250VAC继电器5v）</h2><p><strong>易微联通断器选用了这个继电器</strong></p><p><a href="https://www.aferelay.net/brd/48-89.html">通用功率继电器BRD-SS-105LM</a></p><p><strong>产品特点：</strong><br>1.高触点容量：15A触点高切换能力<br>2.低线圈功耗，低价格<br>3.小型“19<em>15.4</em>15mm，标准印刷板引出脚</p><p>**技术参数：<br>**<img src="/posts/2386778146/5bff4a1082f01.jpg" class="" title="img"></p><img src="/posts/2386778146/65682edc7db1f.jpg" class="" title="通用功率继电器BRD-SS-105LM"><img src="/posts/2386778146/65682eeea4073.jpg" class="" title="BRD-SS-105LM 脚.jpg"><hr><h1 id="相关链接（侵删）"><a href="#相关链接（侵删）" class="headerlink" title="相关链接（侵删）"></a>相关链接（侵删）</h1><hr><center><font color=red>=================我是分割线=================</font></center><p><strong>欢迎到公众号来唠嗑:</strong></p><img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">]]></content>
    
    
    <summary type="html">收集硬件继电器相关资料</summary>
    
    
    
    <category term="硬件" scheme="https://zml3589110.github.io/categories/%E7%A1%AC%E4%BB%B6/"/>
    
    <category term="继电器" scheme="https://zml3589110.github.io/categories/%E7%BB%A7%E7%94%B5%E5%99%A8/"/>
    
    
    <category term="硬件" scheme="https://zml3589110.github.io/tags/%E7%A1%AC%E4%BB%B6/"/>
    
    <category term="继电器" scheme="https://zml3589110.github.io/tags/%E7%BB%A7%E7%94%B5%E5%99%A8/"/>
    
    <category term="三友继电器" scheme="https://zml3589110.github.io/tags/%E4%B8%89%E5%8F%8B%E7%BB%A7%E7%94%B5%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>HomeAssistant小米xiaomi_miot报错ipm不存在</title>
    <link href="https://zml3589110.github.io/posts/1140753793.html"/>
    <id>https://zml3589110.github.io/posts/1140753793.html</id>
    <published>2024-02-19T03:29:20.000Z</published>
    <updated>2024-02-20T01:52:46.064Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://github.com/al-one/hass-xiaomi-miot">小米xiaomi_miot集成仓库地址</a></strong></p><h1 id="集成简介"><a href="#集成简介" class="headerlink" title="集成简介"></a>集成简介</h1><p>MIoT-Spec 是小米IoT平台根据硬件产品的联网方式、产品功能的特点、用户使用场景的特征和用户对硬件产品使用体验的要求，设计的描述硬件产品功能定义的标准规范。</p><p>本插件利用了miot协议的规范，可将小米设备自动接入HomeAssistant，目前已支持大部分小米米家智能设备。且该插件支持HA后台界面集成，无需配置yaml即可轻松将小米设备接入HA。</p><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>昨天在研究玩客云静态问题后<strong>（注：后边是找到了解决方法，使用很多都失败，多次dchp绑定后发现每一次重启MAC地址都会改变，因此设置固定MAC即可，走了很多弯路）</strong></p><ul><li><strong>参考文章解决：</strong><a href="https://zhuanlan.zhihu.com/p/556064376">玩客云刷armbian系统后,不能固定mac地址和设置固定IP问题(已解决)</a></li></ul><p>突然发现这个功能无法加载，每次启动都报错！</p><p>昨天尝试了很多方法，重新卸载然后安装，还有恢复homeassistant到之前备份版本等等</p><p><strong>依然报以下错误：</strong></p><img src="/posts/1140753793/image-20240219114451468.png" class="" title="image-20240219114451468"><p>详情如下：</p><img src="/posts/1140753793/image-20240219114522794.png" class="" title="image-20240219114522794"><p>研究了好久，一直以为 xiaomi_miot 集成库问题，或者兼容性问题，所以方向是放在这两个上面，然而尝试很久依然如此。</p><p>有尝试过修改 xiaomi_miot 的py文件，也是一样不行，网上类似问题也没有</p><p>集成中小米集成一直显示如下：</p><img src="/posts/1140753793/image-20240219114740972.png" class="" title="image-20240219114740972"><p>也就是说集成一直没法使用，但之前明明一直正常，不可能因为做了静态IP影响到它吧？</p><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>方法其实很简单，就是把错误点处理即可。<br>根本原因还是新版本 python 3.12 之后将不提供imp模块，使用import imp 发现会报错。</p><p>当定位到问题之后就好解决了！</p><p>在上边报错信息中看出来，报错位置为：</p><img src="/posts/1140753793/image-20240219133945022.png" class="" title="image-20240219133945022"><p>就是这句话问题，看都最后他调用了 imp 模块，所以解决办法就是屏蔽掉 imp 调用即可</p><h2 id="步骤一：打开相应docker镜像并进入"><a href="#步骤一：打开相应docker镜像并进入" class="headerlink" title="步骤一：打开相应docker镜像并进入"></a>步骤一：打开相应docker镜像并进入</h2><p>查看 homeassistant 的 docker ID并进入到 docker 内部中</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><img src="/posts/1140753793/image-20240219134248021.png" class="" title="image-20240219134248021"><p>使用 <strong>docker exec -it <CONTAINER ID>  &#x2F;bin&#x2F;bash</strong> 命令进入</p><p>当前的镜像名称为：ghcr.io&#x2F;home-assistant&#x2F;raspberrypi3-homeassistant:2024.2.2<br>镜像ID为：3f8ac3040249<br>输入以下命令即可进入config中</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it 3f8ac3040249  /bin/bash</span><br></pre></td></tr></table></figure><h2 id="步骤二：打开报错文件-core-py-并屏蔽-imp-调用"><a href="#步骤二：打开报错文件-core-py-并屏蔽-imp-调用" class="headerlink" title="步骤二：打开报错文件 core.py 并屏蔽 imp 调用"></a>步骤二：打开报错文件 core.py 并屏蔽 imp 调用</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/lib/python3.12/site-packages/construct</span><br></pre></td></tr></table></figure><p><strong>修改之前备份一下，养成好习惯</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi core.py</span><br></pre></td></tr></table></figure><p>屏蔽如下：</p><img src="/posts/1140753793/image-20240219134747931.png" class="" title="image-20240219134747931"><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import struct, io, binascii, itertools, collections, pickle, sys, os, tempfile, hashlib, importlib <span class="comment">#, imp</span></span><br></pre></td></tr></table></figure><h2 id="步骤三：退出docker并重启镜像"><a href="#步骤三：退出docker并重启镜像" class="headerlink" title="步骤三：退出docker并重启镜像"></a>步骤三：退出docker并重启镜像</h2><p>退出：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><p>重启：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart 3f8ac3040249</span><br></pre></td></tr></table></figure><p>之后就能正常使用集成了</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实问题一早都显示在log里边，只是没仔细查看<br>网上查找的也没那么详细<br>加之对 python 的陌生才白耗费昨天一天<br>不过好在最后能发现问题</p><p>所以说，只有知道问题的根本才好解决问题，做什么事情方向对了的话后边就水到渠成，但方向不对努力就真的白搭了<br>这也算侧面学习 python 了。</p><hr><h1 id="相关链接（侵删）"><a href="#相关链接（侵删）" class="headerlink" title="相关链接（侵删）"></a>相关链接（侵删）</h1><ol><li><a href="https://www.cnblogs.com/bugbreak/p/13331211.html">解决Pycharm提示imp报错</a></li></ol><hr><center><font color=red>=================我是分割线=================</font></center><p><strong>欢迎到公众号来唠嗑:</strong></p><img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">]]></content>
    
    
    <summary type="html">xiaomi_miot 集成加载时总是报错，无法加载添加集成，一直报ipm模块找不到</summary>
    
    
    
    <category term="ubuntu" scheme="https://zml3589110.github.io/categories/ubuntu/"/>
    
    <category term="HomeAssistant" scheme="https://zml3589110.github.io/categories/HomeAssistant/"/>
    
    <category term="插件" scheme="https://zml3589110.github.io/categories/%E6%8F%92%E4%BB%B6/"/>
    
    <category term="xiaomi_miot" scheme="https://zml3589110.github.io/categories/xiaomi-miot/"/>
    
    <category term="ipm" scheme="https://zml3589110.github.io/categories/ipm/"/>
    
    <category term="pip" scheme="https://zml3589110.github.io/categories/pip/"/>
    
    
    <category term="智能家居" scheme="https://zml3589110.github.io/tags/%E6%99%BA%E8%83%BD%E5%AE%B6%E5%B1%85/"/>
    
    <category term="HomeAssistant" scheme="https://zml3589110.github.io/tags/HomeAssistant/"/>
    
    <category term="插件" scheme="https://zml3589110.github.io/tags/%E6%8F%92%E4%BB%B6/"/>
    
    <category term="python" scheme="https://zml3589110.github.io/tags/python/"/>
    
    <category term="小米" scheme="https://zml3589110.github.io/tags/%E5%B0%8F%E7%B1%B3/"/>
    
    <category term="xiaomi_miot" scheme="https://zml3589110.github.io/tags/xiaomi-miot/"/>
    
    <category term="imp" scheme="https://zml3589110.github.io/tags/imp/"/>
    
    <category term="错误处理" scheme="https://zml3589110.github.io/tags/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/"/>
    
    <category term="pip" scheme="https://zml3589110.github.io/tags/pip/"/>
    
  </entry>
  
</feed>
